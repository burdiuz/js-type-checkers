{"version":3,"file":"type-checkers.min.js","sources":["../source/checkers/utils.js","../source/target/info.js","../source/checkers/primitive.js","../source/checkers/index.js","../source/reporters/utils.js","../source/reporters/console.js","../source/reporters/index.js","../source/enabled.js","../source/target/proxy.js","../source/proxy/config.js","../source/utils.js","../source/proxy/getProperty.js","../source/proxy/setProperty.js","../source/proxy/utils.js","../source/proxy/create.js","../source/proxy/callFunction.js","../source/proxy/createDeep.js","../source/reporters/error.js","../source/target/objectMerge.js","../source/target/replaceProperty.js"],"sourcesContent":["\nexport const GET_PROPERTY = '(GetProperty)';\nexport const SET_PROPERTY = '(SetProperty)';\nexport const INDEX = '(Index)';\nexport const ARGUMENTS = '(Arguments)';\nexport const RETURN_VALUE = '(ReturnValue)';\nexport const MERGE = '(Merge)';\n\nexport function AsIs(value) {\n  if (this instanceof AsIs) {\n    this.value = value;\n  } else {\n    return new AsIs(value);\n  }\n}\n\nfunction asIs() {\n  return this.value;\n}\n\nAsIs.prototype.toString = asIs;\nAsIs.prototype.valueOf = asIs;\nAsIs.prototype[Symbol.toPrimitive] = asIs;\n\nexport const buildPath = (sequence) => sequence\n  .reduce((str, name) => {\n    if (name instanceof AsIs) {\n      str = `${str}${name}`;\n    } else if (String(parseInt(name, 10)) === name) {\n      str = `${str}[${name}]`;\n    } else if (/^[a-z][\\w$]*$/i.test(name)) {\n      str = str ? `${str}.${name}` : name;\n    } else {\n      str = `${str}[\"${name}\"]`;\n    }\n\n    return str;\n  }, '');\n","export const INFO_KEY = Symbol('type-checkers::info');\n\nexport const createTargetInfo = (\n  checker,\n  config,\n  deep = true,\n  names = [],\n  children = createChildrenCache(),\n) => ({\n  checker,\n  config,\n  deep,\n  names,\n  children,\n});\n\nexport const getTargetInfo = (target) => (target ? target[INFO_KEY] : undefined);\n\nexport const setTargetInfo = (target, info) => {\n  if (target && info) {\n    target[INFO_KEY] = info;\n  }\n};\n\nexport const hasTargetInfo = (target) => !!getTargetInfo(target);\n\nexport const getTargetTypeChecker = (target) =>\n  (target && target[INFO_KEY] ? target[INFO_KEY].checker : undefined);\n\nexport const getTargetTypeCheckerConfig = (target) => {\n  if (!target || !target[INFO_KEY]) {\n    return undefined;\n  }\n\n  return target[INFO_KEY].config;\n};\n\nexport const createChildrenCache = (children = {}) => ({ ...children });\n\nexport const mergeChildrenCache = (targetCache, sourceCache) => {\n  for (const name in sourceCache) {\n    if (targetCache.hasOwnProperty(name)) {\n      targetCache[name] = mergeTargetInfo(targetCache[name], sourceCache[name]);\n    } else {\n      targetCache[name] = sourceCache[name];\n    }\n  }\n\n  return targetCache;\n};\n\nexport const storeChildInfo = (cache, name, childInfo) => {\n  delete cache[name];\n\n  if (childInfo) {\n    cache[name] = childInfo;\n  }\n};\n\nexport const storeChildInfoFrom = (cache, name, child) => {\n  storeChildInfo(cache, name, getTargetInfo(child));\n};\n\nexport const getChildInfo = (cache, name) => cache[name];\n\nexport const hasChildInfo = (cache, name) => !!cache[name];\n\nexport const removeChildInfo = (cache, name) => delete cache[name];\n\nexport const mergeTargetInfo = (targetInfo, sourceInfo) => {\n  const { deep, checker, children, config, names } = targetInfo;\n\n  if (checker === sourceInfo.checker) {\n    targetInfo.deep = deep || sourceInfo.deep;\n    targetInfo.children = mergeChildrenCache(children, sourceInfo.children);\n    targetInfo.config = checker.mergeConfigs(config, sourceInfo.config, names);\n  } else {\n    console.error('TypeChecked objects can be merged only if using exactly same instance of type checker.');\n  }\n\n  return targetInfo;\n};\n","import {\n  ARGUMENTS,\n  GET_PROPERTY,\n  RETURN_VALUE,\n  SET_PROPERTY,\n  INDEX,\n  MERGE,\n  buildPath,\n  AsIs,\n} from './utils';\n\nimport { getTargetTypeCheckerConfig } from '../target/info';\n\nconst checkPrimitiveType = (action, types, name, type, errorReporter, sequence) => {\n  if (!type) {\n    return true;\n  }\n\n  const storedType = types[name];\n\n  if (storedType) {\n    if (storedType !== type) {\n      errorReporter(action, buildPath([...sequence, name]), storedType, type);\n\n      return false;\n    }\n  } else {\n    types[name] = type;\n  }\n\n  return true;\n};\n\nconst indexBasedClasses = [Array];\n\nexport const isIndexAccessTarget = (target) =>\n  (target && indexBasedClasses.indexOf(target.constructor) >= 0);\n\nexport const getTypeString = (value) => {\n  if (value === undefined) {\n    return '';\n  } else if (value instanceof Array) {\n    return 'array';\n  }\n\n  return typeof value;\n};\n\nexport const mergeConfigs = ({ types, errorReporter }, source, names = []) => {\n  const sourceTypes = source.types;\n\n  for (const name in sourceTypes) {\n    if (sourceTypes.hasOwnProperty(name)) {\n      const sourceType = sourceTypes[name];\n      const targetType = types[name];\n\n      if (sourceType && targetType && targetType !== sourceType) {\n        errorReporter(MERGE, buildPath([...names, name]), targetType, sourceType);\n      } else {\n        types[name] = sourceType;\n      }\n    }\n  }\n\n  return { types, errorReporter };\n};\n\nexport const replacePropertyTypeCheck = (target, name, typeCheckFn) => {\n  const { types } = getTargetTypeCheckerConfig(target);\n  delete types[name];\n\n  if (typeCheckFn) {\n    types[name] = typeCheckFn;\n  }\n};\n\nexport const replaceArgumentsTypeCheck = (target, argumentsTypeCheckFn) => {\n  const { types } = getTargetTypeCheckerConfig(target);\n  delete types[ARGUMENTS];\n\n  if (argumentsTypeCheckFn) {\n    types[ARGUMENTS] = argumentsTypeCheckFn;\n  }\n};\n\nexport const replaceReturnValueTypeCheck = (target, returnValueTypeCheckFn) => {\n  const { types } = getTargetTypeCheckerConfig(target);\n  delete types[RETURN_VALUE];\n\n  if (returnValueTypeCheckFn) {\n    types[RETURN_VALUE] = returnValueTypeCheckFn;\n  }\n};\n\nexport const registerIndexBasedClass = (constructor) => {\n  indexBasedClasses.push(constructor);\n};\n\nexport const setIndexValueType = (target, type) => {\n  const config = getTargetTypeCheckerConfig(target);\n  if (config) {\n    config.types[INDEX] = type;\n  }\n};\n\nexport const setIndexValueTypeBy = (target, value) => {\n  setIndexValueType(target, getTypeString(value));\n};\n\nexport const replaceIndexedTypeCheck = (target, typeCheckFn) => {\n  const { types } = getTargetTypeCheckerConfig(target);\n  delete types[INDEX];\n\n  if (typeCheckFn) {\n    types[INDEX] = typeCheckFn;\n  }\n};\n\nconst PrimitiveTypeChecker = {\n  collectTypesOnInit: true,\n  areArrayElementsOfSameType: true,\n\n  init(target, errorReporter, cachedTypes = null) {\n    let types = {};\n\n    if (cachedTypes) {\n      types = cachedTypes;\n    } else if (this.collectTypesOnInit) {\n      if (this.areArrayElementsOfSameType && target instanceof Array) {\n        const indexType = getTypeString(target\n        .find((item) => (typeof item !== 'undefined')));\n\n        if (indexType) {\n          types[INDEX] = indexType;\n        }\n      } else {\n        Object.keys(target)\n          .forEach((key) => {\n            types[key] = getTypeString(target[key]);\n          });\n      }\n    }\n\n    return {\n      types,\n      errorReporter,\n    };\n  },\n\n  getProperty(target, name, value, config, sequence) {\n    if (this.areArrayElementsOfSameType && isIndexAccessTarget(target)) {\n      return this.getIndexProperty(target, INDEX, value, config, sequence);\n    }\n\n    return this.getNamedProperty(target, name, value, config, sequence);\n  },\n\n  getIndexProperty(target, name, value, config, sequence) {\n    const { types, errorReporter } = config;\n    const typeFn = types[name];\n\n    if (typeFn instanceof Function) {\n      return typeFn(GET_PROPERTY, target, name, value, config, sequence);\n    }\n\n    const type = getTypeString(value);\n\n    return checkPrimitiveType(GET_PROPERTY, types, AsIs(INDEX), type, errorReporter, sequence);\n  },\n\n  getNamedProperty(target, name, value, config, sequence) {\n    const { types, errorReporter } = config;\n    const typeFn = types[name];\n\n    if (typeFn instanceof Function) {\n      return typeFn(GET_PROPERTY, target, name, value, config, sequence);\n    }\n\n    const type = getTypeString(value);\n\n    return checkPrimitiveType(GET_PROPERTY, types, name, type, errorReporter, sequence);\n  },\n\n  setProperty(target, name, newValue, config, sequence) {\n    if (this.areArrayElementsOfSameType && isIndexAccessTarget(target)) {\n      return this.setIndexProperty(target, INDEX, newValue, config, sequence);\n    }\n\n    return this.setNamedProperty(target, name, newValue, config, sequence);\n  },\n\n  setIndexProperty(target, name, newValue, config, sequence) {\n    const { types, errorReporter } = config;\n    const typeFn = types[name];\n\n    if (typeFn instanceof Function) {\n      return typeFn(SET_PROPERTY, target, name, newValue, config, sequence);\n    }\n\n    const type = getTypeString(newValue);\n\n    return checkPrimitiveType(SET_PROPERTY, types, AsIs(INDEX), type, errorReporter, sequence);\n  },\n\n  setNamedProperty(target, name, newValue, config, sequence) {\n    const { types, errorReporter } = config;\n    const typeFn = types[name];\n\n    if (typeFn instanceof Function) {\n      return typeFn(SET_PROPERTY, target, name, newValue, config, sequence);\n    }\n\n    const type = getTypeString(newValue);\n\n    return checkPrimitiveType(SET_PROPERTY, types, name, type, errorReporter, sequence);\n  },\n\n  arguments(target, thisArg, args, config, sequence) {\n    const { types, errorReporter } = config;\n    const typeFn = types[ARGUMENTS];\n\n    if (typeFn instanceof Function) {\n      return typeFn(ARGUMENTS, target, args, config, sequence);\n    }\n\n    const { length } = args;\n    let valid = true;\n\n    for (let index = 0; index < length; index++) {\n      const type = getTypeString(args[index]);\n      const agrValid = checkPrimitiveType(ARGUMENTS, types, String(index), type, errorReporter, sequence);\n\n      valid = agrValid && valid;\n    }\n\n    return valid;\n  },\n\n  returnValue(target, thisArg, value, config, sequence) {\n    const { types, errorReporter } = config;\n    const typeFn = types[RETURN_VALUE];\n\n    if (typeFn instanceof Function) {\n      return typeFn(RETURN_VALUE, target, value, config, sequence);\n    }\n\n    const type = getTypeString(value);\n\n    return checkPrimitiveType(RETURN_VALUE, types, AsIs(RETURN_VALUE), type, errorReporter, sequence);\n  },\n\n  isIndexAccessTarget,\n  getTypeString,\n  mergeConfigs,\n  replacePropertyTypeCheck,\n  replaceArgumentsTypeCheck,\n  replaceReturnValueTypeCheck,\n  registerIndexBasedClass,\n  setIndexValueType,\n  setIndexValueTypeBy,\n  replaceIndexedTypeCheck,\n};\n\nexport default PrimitiveTypeChecker;\n","import PrimitiveTypeChecker from './primitive';\n\nlet defaultTypeChecker = PrimitiveTypeChecker;\n\nconst getDefaultTypeChecker = () => defaultTypeChecker;\nconst setDefaultTypeChecker = (typeChecker) => {\n  defaultTypeChecker = typeChecker;\n};\n\nexport {\n  PrimitiveTypeChecker,\n  getDefaultTypeChecker,\n  setDefaultTypeChecker,\n};\n","export const constructErrorString = (action, name, required, actual) =>\n  `${action}Error on \"${name}\" instead of \"${required}\" received \"${actual}\"`;\n","import { constructErrorString } from './utils';\n\nexport const ConsoleErrorReporter = (action, name, requiredTypeString, actualTypeString) =>\n  console.error(constructErrorString(action, name, requiredTypeString, actualTypeString));\n\nexport const ConsoleWarnReporter = (action, name, requiredTypeString, actualTypeString) =>\n  console.warn(constructErrorString(action, name, requiredTypeString, actualTypeString));\n","import { ConsoleErrorReporter } from './console';\n\nlet errorReporter = ConsoleErrorReporter;\n\nexport const getErrorReporter = () => errorReporter;\n\nexport const setErrorReporter = (reporter) => errorReporter = reporter;\n","let enabled = true;\n\nexport const isEnabled = () => enabled;\nexport const setEnabled = (value = true) => {\n  enabled = !!value;\n};\n","export const TARGET_KEY = Symbol('type-checkers::target');\n\nexport const getOriginalTarget = (target) => {\n  return target[TARGET_KEY] || target;\n};\n","export const PROXY_WRAP_FUNCTION_RETURN_VALUES = 'wrapFunctionReturnValues';\nexport const PROXY_WRAP_FUNCTION_ARGUMENTS = 'wrapFunctionArguments';\nexport const PROXY_WRAP_SET_PROPERTY_VALUES = 'wrapSetPropertyValues';\nexport const PROXY_IGNORE_PROTOTYPE_METHODS = 'ignorePrototypeMethods';\n\nexport const getDefaultProxyConfig = () => ({\n  [PROXY_WRAP_FUNCTION_RETURN_VALUES]: true,\n  [PROXY_WRAP_FUNCTION_ARGUMENTS]: false,\n  [PROXY_WRAP_SET_PROPERTY_VALUES]: true,\n  [PROXY_IGNORE_PROTOTYPE_METHODS]: false,\n});\n\nconst config = getDefaultProxyConfig();\n\nexport const setProxyConfig = (newConfig) => Object.assign(config, newConfig);\n\nexport const getProxyConfig = () => ({ ...config });\n\nexport const getProxyConfigValue = (key, info = null) =>\n  (info && info.hasOwnProperty(key) ? info[key] : config[key]);\n","import { TARGET_KEY } from './target/proxy';\n\nconst validTypes = {\n  object: true,\n  function: true,\n};\n\nexport const isValidTarget = (target) => Boolean(target && validTypes[typeof target]);\nexport const isTypeChecked = (target) => Boolean(target && target[TARGET_KEY]);\n","import {\n  INFO_KEY,\n  getTargetInfo,\n  getChildInfo,\n  storeChildInfoFrom,\n} from '../target/info';\n\nimport {\n  getProxyConfigValue,\n  PROXY_IGNORE_PROTOTYPE_METHODS,\n} from './config';\n\nimport {\n  isValidTarget,\n  isTypeChecked,\n} from '../utils';\n\nimport { TARGET_KEY } from '../target/proxy';\n\nconst getTargetProperty = (createFn, target, property, value) => {\n  const info = getTargetInfo(target);\n  const { deep, children, names, checker } = info;\n\n  if (deep || value instanceof Function) {\n    const childInfo = getChildInfo(children, property);\n\n    if (childInfo) {\n      value = createFn(value, { info: childInfo });\n    } else {\n      value = createFn(value, { deep, names: [...names, property], checker });\n      storeChildInfoFrom(children, property, value);\n    }\n  }\n\n  return value;\n};\n\nconst isIgnoredProperty = (target, info, property, value) => {\n  if (\n    value instanceof Function\n    && !target.hasOwnProperty(property)\n    && getProxyConfigValue(PROXY_IGNORE_PROTOTYPE_METHODS, info)\n  ) {\n    return true;\n  }\n\n  return false;\n};\n\nconst getProperty = (createFn) => (target, property) => {\n  const value = target[property];\n\n  if (property === INFO_KEY) {\n    return value;\n    /*\n    target[TARGET_KEY] is a virtual property accessing which indicates\n    if object is wrapped with type checked proxy or not.\n    */\n  } else if (property === TARGET_KEY) {\n    return target;\n  }\n\n  const info = getTargetInfo(target);\n  const { names, config, checker } = info;\n\n  if (checker.getProperty) {\n    checker.getProperty(target, property, value, config, names);\n  }\n\n  if (\n    !isValidTarget(value)\n    || isTypeChecked(value)\n    || isIgnoredProperty(target, info, property, value)\n  ) {\n    return value;\n  }\n\n  return getTargetProperty(createFn, target, property, value);\n};\n\nexport default getProperty;\n","import {\n  INFO_KEY,\n  getTargetInfo,\n  getChildInfo,\n  storeChildInfoFrom,\n  mergeTargetInfo,\n} from '../target/info';\n\nimport {\n  getProxyConfigValue,\n  PROXY_WRAP_SET_PROPERTY_VALUES,\n} from './config';\n\nimport {\n  isValidTarget,\n  isTypeChecked,\n} from '../utils';\n\nimport { TARGET_KEY } from '../target/proxy';\n\nconst setNonTargetProperty = (target, property, value) => {\n  if (property === INFO_KEY) {\n    let info = getTargetInfo(target);\n    if (info && value && info !== value) {\n      info = mergeTargetInfo(info, value);\n    } else {\n      info = value;\n    }\n\n    target[property] = info;\n    return true;\n  } else if (!isValidTarget(value)) {\n    const { names, config, checker } = getTargetInfo(target);\n\n    if (checker.setProperty) {\n      checker.setProperty(target, property, value, config, names);\n    }\n\n    target[property] = value;\n    return true;\n  }\n\n  return false;\n};\n\nconst setTargetProperty = (createFn, target, property, value) => {\n  const info = getTargetInfo(target);\n  const { deep, names, checker, config, children } = info;\n\n  if (checker.setProperty) {\n    checker.setProperty(target, property, value, config, names);\n  }\n\n  if (getProxyConfigValue(PROXY_WRAP_SET_PROPERTY_VALUES, info)) {\n    if (!isTypeChecked(value)) {\n      const childInfo = getChildInfo(children, property);\n\n      if (childInfo) {\n        value = createFn(value, { info: childInfo });\n      } else {\n        value = createFn(value, { deep, names: [...names, property], checker });\n      }\n    }\n\n    storeChildInfoFrom(children, property, value);\n  }\n\n  target[property] = value;\n  return true;\n};\n\nconst setProperty = (createFn) => (target, property, value) => {\n  if (property === TARGET_KEY) {\n    throw new Error(`\"${TARGET_KEY}\" is a virtual property and cannot be set`);\n  }\n\n  return setNonTargetProperty(target, property, value)\n    || setTargetProperty(createFn, target, property, value);\n};\n\nexport default setProperty;\n","import { isTypeChecked, isValidTarget } from '../utils';\nimport { getChildInfo, storeChildInfoFrom } from '../target/info';\n\nexport const getTypeCheckedChild = (createFn, info, name, value) => {\n  if (!isValidTarget(value)) {\n    return value;\n  }\n\n  let result = value;\n\n  if (!isTypeChecked(value)) {\n    const { children } = info;\n    const childInfo = getChildInfo(children, name);\n\n    if (childInfo) {\n      result = createFn(value, { info: childInfo });\n    } else {\n      const { deep, names, checker } = info;\n      result = createFn(value, { deep, names: [...names, name], checker });\n      storeChildInfoFrom(children, name, result);\n    }\n  }\n\n  return result;\n};\n","import { getDefaultTypeChecker } from '../checkers';\nimport { getErrorReporter } from '../reporters';\nimport { isEnabled } from '../enabled';\nimport {\n  createTargetInfo,\n  setTargetInfo,\n  createChildrenCache,\n} from '../target/info';\nimport { isValidTarget, isTypeChecked } from '../utils';\nimport getPropertyInit from './getProperty';\nimport setPropertyInit from './setProperty';\nimport callFunctionInit from './callFunction';\n\nlet getProperty;\nlet setProperty;\nlet callFunction;\n\nconst objectProxy = (target) => new Proxy(\n  target,\n  {\n    get: getProperty,\n    set: setProperty,\n  },\n);\n\nconst functionProxy = (target) => new Proxy(\n  target,\n  {\n    get: getProperty,\n    set: setProperty,\n    apply: callFunction,\n    construct: callFunction,\n  },\n);\n\nexport const wrapWithProxy = (target) => {\n  if (target instanceof Function) {\n    return functionProxy(target);\n  }\n\n  return objectProxy(target);\n};\n\nexport const createInfoFromOptions = (target, {\n  deep = true,\n  names = [],\n  config = null,\n  children = null,\n  checker = getDefaultTypeChecker(),\n  info = null, // exclusive option, if set other options being ignored\n} = {}) => info || createTargetInfo(\n  checker,\n  checker.init(target, getErrorReporter(), config),\n  deep,\n  names,\n  createChildrenCache(children),\n);\n\nconst create = (target, options) => {\n  if (!isValidTarget(target) || !isEnabled() || isTypeChecked(target)) {\n    return target;\n  }\n\n  setTargetInfo(\n    target,\n    createInfoFromOptions(target, options),\n  );\n\n  return wrapWithProxy(target);\n};\n\ngetProperty = getPropertyInit(create);\nsetProperty = setPropertyInit(create);\ncallFunction = callFunctionInit(create);\n\nexport default create;\n","import {\n  getTargetInfo,\n  getChildInfo,\n  storeChildInfoFrom,\n} from '../target/info';\n\nimport {\n  getProxyConfigValue,\n  PROXY_WRAP_FUNCTION_ARGUMENTS,\n  PROXY_WRAP_FUNCTION_RETURN_VALUES,\n} from './config';\n\nimport { isTypeChecked } from '../utils';\n\nimport { RETURN_VALUE, AsIs } from '../checkers/utils';\nimport { getTypeCheckedChild } from './utils';\n\nconst getTargetArguments = (createFn, target, argumentsList) => {\n  const info = getTargetInfo(target);\n\n  if (getProxyConfigValue(PROXY_WRAP_FUNCTION_ARGUMENTS, info)) {\n    const { length } = argumentsList;\n    // FIXME cache arguments info objects as children\n    for (let index = 0; index < length; index++) {\n      argumentsList[index] = getTypeCheckedChild(createFn, info, String(index), argumentsList[index]);\n    }\n  }\n\n  return argumentsList;\n};\n\nconst callFunction = (createFn) => (target, thisArg, argumentsList) => {\n  const info = getTargetInfo(target);\n  const { names, config, checker } = info;\n\n  if (checker.arguments) {\n    checker.arguments(target, thisArg, argumentsList, config, names);\n  }\n\n  argumentsList = getTargetArguments(createFn, target, argumentsList);\n\n  let result = target.apply(thisArg, argumentsList);\n\n  if (checker.returnValue) {\n    checker.returnValue(target, thisArg, result, config, names);\n  }\n\n  if (getProxyConfigValue(PROXY_WRAP_FUNCTION_RETURN_VALUES, info)) {\n    result = getTypeCheckedChild(createFn, info, new AsIs(RETURN_VALUE), result);\n  }\n\n  return result;\n};\n\nexport default callFunction;\n","import { isEnabled } from '../enabled';\nimport {\n  setTargetInfo,\n  storeChildInfo,\n  getChildInfo,\n} from '../target/info';\nimport { isTypeChecked } from '../utils';\nimport { wrapWithProxy, createInfoFromOptions } from './create';\n\nconst deepInitializer = (target, options) => {\n  const info = createInfoFromOptions(target, options);\n  const { deep, names, checker, config, children } = info;\n\n  Object.keys(target)\n    .forEach((name) => {\n      const value = target[name];\n\n      checker.getProperty(target, name, value, config, names);\n\n      // skip functions/methods since we get info about them only when being executed\n      if (typeof value === 'object') {\n        let childInfo = getChildInfo(children, name);\n\n        if (childInfo) {\n          deepInitializer(value, { info: childInfo });\n        } else {\n          childInfo = deepInitializer(value, { deep, names: [...names, name], checker });\n          storeChildInfo(children, name, childInfo);\n        }\n      }\n    });\n\n  setTargetInfo(target, info);\n\n  return info;\n};\n\nconst createDeep = (target, options) => {\n  if (!target || typeof target !== 'object' || !isEnabled() || isTypeChecked(target)) {\n    return target;\n  }\n\n  deepInitializer(target, options);\n\n  return wrapWithProxy(target);\n};\n\nexport default createDeep;\n","import { constructErrorString } from './utils';\n\nexport const ThrowErrorReporter = (action, name, requiredTypeString, actualTypeString) => {\n  throw new Error(constructErrorString(action, name, requiredTypeString, actualTypeString));\n};\n","import {\n  getTargetInfo,\n  hasTargetInfo,\n} from './info';\n\nimport { create } from '../proxy';\n\nimport { isEnabled } from '../enabled';\n\nconst objectMerge = (options, ...sources) => {\n  let target = {};\n\n  if (isEnabled()) {\n    if (!options) {\n      options = {\n        info: getTargetInfo(sources.find((item) => hasTargetInfo(item))),\n        deep: false,\n      };\n    }\n\n    target = create(target, options);\n  }\n\n  return Object.assign(target, ...sources);\n};\n\nexport default objectMerge;\n","import { isEnabled } from '../enabled';\nimport { isValidTarget, isTypeChecked } from '../utils';\n\n// TODO if enabled, replaces original value with type checked\nconst replaceProperty = (target, name, options) => {\n  const value = target[name];\n\n  if (!isEnabled() || !isValidTarget(value) || isTypeChecked(value)) {\n    return target;\n  }\n\n  return target;\n};\n\nexport default replaceProperty;\n"],"names":["GET_PROPERTY","SET_PROPERTY","INDEX","ARGUMENTS","RETURN_VALUE","AsIs","value","this","asIs","prototype","toString","valueOf","Symbol","toPrimitive","buildPath","sequence","reduce","str","name","String","parseInt","test","getTargetInfo","target","INFO_KEY","undefined","setTargetInfo","info","hasTargetInfo","getTargetTypeCheckerConfig","config","createChildrenCache","children","storeChildInfo","cache","childInfo","storeChildInfoFrom","child","getChildInfo","mergeTargetInfo","targetInfo","sourceInfo","deep","checker","names","targetCache","sourceCache","hasOwnProperty","mergeChildrenCache","mergeConfigs","error","checkPrimitiveType","action","types","type","errorReporter","storedType","indexBasedClasses","Array","isIndexAccessTarget","indexOf","constructor","getTypeString","setIndexValueType","PrimitiveTypeChecker","cachedTypes","collectTypesOnInit","areArrayElementsOfSameType","indexType","find","item","keys","forEach","key","getIndexProperty","getNamedProperty","typeFn","Function","newValue","setIndexProperty","setNamedProperty","thisArg","args","length","valid","index","source","sourceTypes","sourceType","targetType","typeCheckFn","argumentsTypeCheckFn","returnValueTypeCheckFn","push","defaultTypeChecker","getDefaultTypeChecker","constructErrorString","required","actual","actualTypeString","ConsoleErrorReporter","getErrorReporter","enabled","isEnabled","TARGET_KEY","PROXY_WRAP_FUNCTION_RETURN_VALUES","PROXY_WRAP_FUNCTION_ARGUMENTS","PROXY_WRAP_SET_PROPERTY_VALUES","PROXY_IGNORE_PROTOTYPE_METHODS","getProxyConfigValue","isValidTarget","Boolean","validTypes","isTypeChecked","property","getTypeCheckedChild","createFn","result","getProperty","setProperty","callFunction","wrapWithProxy","Proxy","createInfoFromOptions","createTargetInfo","init","create","options","getTargetProperty","Error","setNonTargetProperty","setTargetProperty","argumentsList","arguments","getTargetArguments","apply","returnValue","deepInitializer","typeChecker","requiredTypeString","console","warn","reporter","sources","Object","assign","newConfig"],"mappings":"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"}