{"version":3,"file":"type-checkers.min.js","sources":["../source/checkers/index.js","../node_modules/@actualwave/hasOwn/hasOwn.js","../source/proxy/config.js","../source/reporters/utils.js","../source/reporters/console.js","../source/reporters/index.js","../source/enabled.js","../source/target/info.js","../source/target/proxy.js","../source/utils.js","../source/proxy/utils.js","../source/proxy/create.js","../source/proxy/getProperty.js","../source/proxy/setProperty.js","../source/proxy/callFunction.js","../source/proxy/createDeep.js","../source/reporters/error.js","../source/target/object/merge.js","../source/target/object/properties.js"],"sourcesContent":["let defaultTypeChecker = null;\n\nconst getDefaultTypeChecker = () => defaultTypeChecker;\nconst setDefaultTypeChecker = (typeChecker) => {\n  defaultTypeChecker = typeChecker;\n};\n\nexport {\n  getDefaultTypeChecker,\n  setDefaultTypeChecker,\n};\n","'use strict';\n\nObject.defineProperty(exports, '__esModule', { value: true });\n\nconst hasOwn = (\n  (has) =>\n  (target, property) =>\n  Boolean(target && has.call(target, property))\n)(Object.prototype.hasOwnProperty);\n\nexports.hasOwn = hasOwn;\nexports.default = hasOwn;","import hasOwn from '@actualwave/hasOwn';\n\nexport const PROXY_WRAP_FUNCTION_RETURN_VALUES = 'wrapFunctionReturnValues';\nexport const PROXY_WRAP_FUNCTION_ARGUMENTS = 'wrapFunctionArguments';\nexport const PROXY_WRAP_SET_PROPERTY_VALUES = 'wrapSetPropertyValues';\nexport const PROXY_IGNORE_PROTOTYPE_METHODS = 'ignorePrototypeMethods';\n\nexport const getDefaultProxyConfig = () => ({\n  [PROXY_WRAP_FUNCTION_RETURN_VALUES]: true,\n  [PROXY_WRAP_FUNCTION_ARGUMENTS]: false,\n  [PROXY_WRAP_SET_PROPERTY_VALUES]: true,\n  [PROXY_IGNORE_PROTOTYPE_METHODS]: false,\n});\n\nconst config = getDefaultProxyConfig();\n\nexport const setProxyConfig = (newConfig) => Object.assign(config, newConfig);\n\nexport const getProxyConfig = () => ({ ...config });\n\nexport const getProxyConfigValue = (key, info = null) =>\n  (hasOwn(info, key) ? info[key] : config[key]);\n","export const constructErrorString = (action, name, required, actual) =>\n  `${action}Error on \"${name}\" instead of \"${required}\" received \"${actual}\"`;\n","import { constructErrorString } from './utils';\n\nexport const ConsoleErrorReporter = (action, name, requiredTypeString, actualTypeString) =>\n  console.error(constructErrorString(action, name, requiredTypeString, actualTypeString));\n\nexport const ConsoleWarnReporter = (action, name, requiredTypeString, actualTypeString) =>\n  console.warn(constructErrorString(action, name, requiredTypeString, actualTypeString));\n","import {\n  ConsoleErrorReporter,\n  ConsoleWarnReporter,\n} from './console';\nimport { ThrowErrorReporter } from './error';\n\nlet errorReporter = ConsoleErrorReporter;\n\nconst getErrorReporter = () => errorReporter;\n\nconst setErrorReporter = (reporter) => {\n  errorReporter = reporter;\n};\n\nexport {\n  ConsoleErrorReporter,\n  ConsoleWarnReporter,\n  ThrowErrorReporter,\n  getErrorReporter,\n  setErrorReporter,\n};\n","let enabled = true;\n\nexport const isEnabled = () => enabled;\nexport const setEnabled = (value = true) => {\n  enabled = !!value;\n};\n","import hasOwn from '@actualwave/hasOwn';\n\nexport const INFO_KEY = Symbol('type-checkers::info');\n\nexport const createChildrenCache = (children = {}) => ({ ...children });\n\nexport const createTargetInfo = (\n  checker,\n  config,\n  deep = true,\n  names = [],\n  children = createChildrenCache(),\n) => ({\n  checker,\n  config,\n  deep,\n  names,\n  children,\n});\n\nexport const getTargetInfo = (target) => (target ? target[INFO_KEY] : undefined);\n\nexport const setTargetInfo = (target, info) => {\n  if (target && info) {\n    target[INFO_KEY] = info;\n  }\n};\n\nexport const hasTargetInfo = (target) => !!getTargetInfo(target);\n\nexport const getTargetTypeChecker = (target) =>\n  (target && target[INFO_KEY] ? target[INFO_KEY].checker : undefined);\n\nexport const getTargetTypeCheckerConfig = (target) => {\n  if (!target || !target[INFO_KEY]) {\n    return undefined;\n  }\n\n  return target[INFO_KEY].config;\n};\n\nexport const mergeChildrenCache = (targetCache, sourceCache) => {\n  for (const name in sourceCache) {\n    if (hasOwn(targetCache, name)) {\n      targetCache[name] = mergeTargetInfo(targetCache[name], sourceCache[name]);\n    } else {\n      targetCache[name] = sourceCache[name];\n    }\n  }\n\n  return targetCache;\n};\n\nexport const storeChildInfo = (cache, name, childInfo) => {\n  delete cache[name];\n\n  if (childInfo) {\n    cache[name] = childInfo;\n  }\n};\n\nexport const storeChildInfoFrom = (cache, name, child) => {\n  storeChildInfo(cache, name, getTargetInfo(child));\n};\n\nexport const getChildInfo = (cache, name) => cache[name];\n\nexport const hasChildInfo = (cache, name) => !!cache[name];\n\nexport const removeChildInfo = (cache, name) => delete cache[name];\n\nexport const mergeTargetInfo = (targetInfo, sourceInfo) => {\n  const { deep, checker, children, config, names } = targetInfo;\n\n  if (checker === sourceInfo.checker) {\n    targetInfo.deep = deep || sourceInfo.deep;\n    targetInfo.children = mergeChildrenCache(children, sourceInfo.children);\n    targetInfo.config = checker.mergeConfigs(config, sourceInfo.config, names);\n  } else {\n    console.error('TypeChecked objects can be merged only if using exactly same instance of type checker.');\n  }\n\n  return targetInfo;\n};\n","export const TARGET_KEY = Symbol('type-checkers::target');\n\nexport const getOriginalTarget = (target) => {\n  return target[TARGET_KEY] || target;\n};\n","import { TARGET_KEY } from './target/proxy';\n\nconst validTypes = {\n  object: true,\n  function: true,\n};\n\nexport const isValidTarget = (target) => Boolean(target && validTypes[typeof target]);\nexport const isTypeChecked = (target) => Boolean(target && target[TARGET_KEY]);\n","import { isTypeChecked, isValidTarget } from '../utils';\nimport { getChildInfo, storeChildInfoFrom } from '../target/info';\n\nexport const getTypeCheckedChild = (createFn, info, name, value) => {\n  if (!isValidTarget(value)) {\n    return value;\n  }\n\n  let result = value;\n\n  if (!isTypeChecked(value)) {\n    const { children } = info;\n    const childInfo = getChildInfo(children, name);\n\n    if (childInfo) {\n      result = createFn(value, { info: childInfo });\n    } else {\n      const { deep, names, checker } = info;\n      result = createFn(value, { deep, names: [...names, name], checker });\n      storeChildInfoFrom(children, name, result);\n    }\n  }\n\n  return result;\n};\n","import { getDefaultTypeChecker } from '../checkers';\nimport { getErrorReporter } from '../reporters';\nimport { isEnabled } from '../enabled';\nimport {\n  createTargetInfo,\n  setTargetInfo,\n  createChildrenCache,\n} from '../target/info';\nimport { isValidTarget, isTypeChecked } from '../utils';\nimport getPropertyInit from './getProperty';\nimport setPropertyInit from './setProperty';\nimport callFunctionInit from './callFunction';\n\nlet getProperty;\nlet setProperty;\nlet callFunction;\n\nconst objectProxy = (target) => new Proxy(\n  target,\n  {\n    get: getProperty,\n    set: setProperty,\n  },\n);\n\nconst functionProxy = (target) => new Proxy(\n  target,\n  {\n    get: getProperty,\n    set: setProperty,\n    apply: callFunction,\n    construct: callFunction,\n  },\n);\n\nexport const wrapWithProxy = (target) => {\n  if (target instanceof Function) {\n    return functionProxy(target);\n  }\n\n  return objectProxy(target);\n};\n\nexport const createInfoFromOptions = (target, {\n  deep = true,\n  names = [],\n  config = null,\n  children = null,\n  checker = getDefaultTypeChecker(),\n  info = null, // exclusive option, if set other options being ignored\n} = {}) => info || createTargetInfo(\n  checker,\n  checker.init(target, getErrorReporter(), config),\n  deep,\n  names,\n  createChildrenCache(children),\n);\n\nconst create = (target, options) => {\n  if (!isValidTarget(target) || !isEnabled() || isTypeChecked(target)) {\n    return target;\n  }\n\n  setTargetInfo(\n    target,\n    createInfoFromOptions(target, options),\n  );\n\n  return wrapWithProxy(target);\n};\n\ngetProperty = getPropertyInit(create);\nsetProperty = setPropertyInit(create);\ncallFunction = callFunctionInit(create);\n\nexport default create;\n","import hasOwn from '@actualwave/hasOwn';\n\nimport {\n  INFO_KEY,\n  getTargetInfo,\n  getChildInfo,\n  storeChildInfoFrom,\n} from '../target/info';\n\nimport {\n  getProxyConfigValue,\n  PROXY_IGNORE_PROTOTYPE_METHODS,\n} from './config';\n\nimport {\n  isValidTarget,\n  isTypeChecked,\n} from '../utils';\n\nimport { TARGET_KEY } from '../target/proxy';\n\nconst getTargetProperty = (createFn, target, property, value) => {\n  const info = getTargetInfo(target);\n  const { deep, children, names, checker } = info;\n\n  if (deep || value instanceof Function) {\n    const childInfo = getChildInfo(children, property);\n\n    if (childInfo) {\n      value = createFn(value, { info: childInfo });\n    } else {\n      value = createFn(value, { deep, names: [...names, property], checker });\n      storeChildInfoFrom(children, property, value);\n    }\n  }\n\n  return value;\n};\n\nconst isIgnoredProperty = (target, info, property, value) => {\n  if (\n    value instanceof Function\n    && !hasOwn(target, property)\n    && getProxyConfigValue(PROXY_IGNORE_PROTOTYPE_METHODS, info)\n  ) {\n    return true;\n  }\n\n  return false;\n};\n\nconst getProperty = (createFn) => (target, property) => {\n  const value = target[property];\n\n  if (property === INFO_KEY) {\n    return value;\n    /*\n    target[TARGET_KEY] is a virtual property accessing which indicates\n    if object is wrapped with type checked proxy or not.\n    */\n  } else if (property === TARGET_KEY) {\n    return target;\n  }\n\n  const info = getTargetInfo(target);\n  const { names, config, checker } = info;\n\n  if (checker.getProperty) {\n    checker.getProperty(target, property, value, config, names);\n  }\n\n  if (\n    !isValidTarget(value)\n    || isTypeChecked(value)\n    || isIgnoredProperty(target, info, property, value)\n  ) {\n    return value;\n  }\n\n  return getTargetProperty(createFn, target, property, value);\n};\n\nexport default getProperty;\n","import {\n  INFO_KEY,\n  getTargetInfo,\n  getChildInfo,\n  storeChildInfoFrom,\n  mergeTargetInfo,\n} from '../target/info';\n\nimport {\n  getProxyConfigValue,\n  PROXY_WRAP_SET_PROPERTY_VALUES,\n} from './config';\n\nimport {\n  isValidTarget,\n  isTypeChecked,\n} from '../utils';\n\nimport { TARGET_KEY } from '../target/proxy';\n\nconst setNonTargetProperty = (target, property, value) => {\n  if (property === INFO_KEY) {\n    let info = getTargetInfo(target);\n    if (info && value && info !== value) {\n      info = mergeTargetInfo(info, value);\n    } else {\n      info = value;\n    }\n\n    target[property] = info;\n    return true;\n  } else if (!isValidTarget(value)) {\n    const { names, config, checker } = getTargetInfo(target);\n\n    if (checker.setProperty) {\n      checker.setProperty(target, property, value, config, names);\n    }\n\n    target[property] = value;\n    return true;\n  }\n\n  return false;\n};\n\nconst setTargetProperty = (createFn, target, property, value) => {\n  const info = getTargetInfo(target);\n  const { deep, names, checker, config, children } = info;\n\n  if (checker.setProperty) {\n    checker.setProperty(target, property, value, config, names);\n  }\n\n  if (getProxyConfigValue(PROXY_WRAP_SET_PROPERTY_VALUES, info)) {\n    if (!isTypeChecked(value)) {\n      const childInfo = getChildInfo(children, property);\n\n      if (childInfo) {\n        value = createFn(value, { info: childInfo });\n      } else {\n        value = createFn(value, { deep, names: [...names, property], checker });\n      }\n    }\n\n    storeChildInfoFrom(children, property, value);\n  }\n\n  target[property] = value;\n  return true;\n};\n\nconst setProperty = (createFn) => (target, property, value) => {\n  if (property === TARGET_KEY) {\n    throw new Error(`\"${TARGET_KEY}\" is a virtual property and cannot be set`);\n  }\n\n  return setNonTargetProperty(target, property, value)\n    || setTargetProperty(createFn, target, property, value);\n};\n\nexport default setProperty;\n","import { getTargetInfo } from '../target/info';\n\nimport {\n  getProxyConfigValue,\n  PROXY_WRAP_FUNCTION_ARGUMENTS,\n  PROXY_WRAP_FUNCTION_RETURN_VALUES\n} from './config';\n\nimport { getTypeCheckedChild } from './utils';\n\nconst getTargetArguments = (createFn, target, argumentsList) => {\n  const info = getTargetInfo(target);\n\n  if (getProxyConfigValue(PROXY_WRAP_FUNCTION_ARGUMENTS, info)) {\n    const { length } = argumentsList;\n    // FIXME cache arguments info objects as children\n    for (let index = 0; index < length; index++) {\n      argumentsList[index] = getTypeCheckedChild(\n        createFn,\n        info,\n        String(index),\n        argumentsList[index]\n      );\n    }\n  }\n\n  return argumentsList;\n};\n\nconst callFunction = (createFn) => (target, thisArg, argumentsList) => {\n  const info = getTargetInfo(target);\n  const { names, config, checker } = info;\n\n  if (checker.arguments) {\n    checker.arguments(target, thisArg, argumentsList, config, names);\n  }\n\n  argumentsList = getTargetArguments(createFn, target, argumentsList);\n\n  let result = target.apply(thisArg, argumentsList);\n\n  if (checker.returnValue) {\n    checker.returnValue(target, thisArg, result, config, names);\n  }\n\n  if (getProxyConfigValue(PROXY_WRAP_FUNCTION_RETURN_VALUES, info)) {\n    result = getTypeCheckedChild(createFn, info, 'returnValue', result);\n  }\n\n  return result;\n};\n\nexport default callFunction;\n","import { isEnabled } from '../enabled';\nimport {\n  setTargetInfo,\n  storeChildInfo,\n  getChildInfo,\n} from '../target/info';\nimport { isTypeChecked } from '../utils';\nimport { wrapWithProxy, createInfoFromOptions } from './create';\n\nconst deepInitializer = (target, options) => {\n  const info = createInfoFromOptions(target, options);\n  const { deep, names, checker, config, children } = info;\n\n  Object.keys(target)\n    .forEach((name) => {\n      const value = target[name];\n\n      checker.getProperty(target, name, value, config, names);\n\n      // skip functions/methods since we get info about them only when being executed\n      if (typeof value === 'object') {\n        let childInfo = getChildInfo(children, name);\n\n        if (childInfo) {\n          deepInitializer(value, { info: childInfo });\n        } else {\n          childInfo = deepInitializer(value, { deep, names: [...names, name], checker });\n          storeChildInfo(children, name, childInfo);\n        }\n      }\n    });\n\n  setTargetInfo(target, info);\n\n  return info;\n};\n\nconst createDeep = (target, options) => {\n  if (!target || typeof target !== 'object' || !isEnabled() || isTypeChecked(target)) {\n    return target;\n  }\n\n  deepInitializer(target, options);\n\n  return wrapWithProxy(target);\n};\n\nexport default createDeep;\n","import { constructErrorString } from './utils';\n\nexport const ThrowErrorReporter = (action, name, requiredTypeString, actualTypeString) => {\n  throw new Error(constructErrorString(action, name, requiredTypeString, actualTypeString));\n};\n","import {\n  getTargetInfo,\n  hasTargetInfo,\n} from '../info';\n\nimport create from '../../proxy/create';\n\nimport { isEnabled } from '../../enabled';\n\nconst objectMerge = (options, ...sources) => {\n  let target = {};\n\n  if (isEnabled()) {\n    if (!options) {\n      options = {\n        info: getTargetInfo(sources.find((item) => hasTargetInfo(item))),\n        deep: false,\n      };\n    }\n\n    target = create(target, options);\n  }\n\n  return Object.assign(target, ...sources);\n};\n\nexport default objectMerge;\n","import { isEnabled } from '../../enabled';\nimport { isValidTarget, isTypeChecked } from '../../utils';\nimport create from '../../proxy/create';\n\n// TODO if enabled, replaces original value with type checked\nconst properties = (target, options = undefined, ...names) => {\n  if (!isEnabled()) {\n    return target;\n  }\n\n  if (!isValidTarget(target)) {\n    throw new Error('Target must be a valid object.');\n  }\n\n  if (Object.isFrozen(target) || Object.isSealed(target)) {\n    throw new Error('Target object should not be sealed or frozen.');\n  }\n\n  if (!names.length) {\n    // Symbols and non-enumerables must be explicitly specified\n    names = Object.keys(target);\n  }\n\n  const { length } = names;\n  for (let index = 0; index < length; index += 1) {\n    const name = names[index];\n    const { writable, get, set } = Object.getOwnPropertyDescriptor(target, name);\n\n    // Prohibit applying to properties with accessor/mutator pair?\n    if ((get && set) || writable) {\n      const value = target[name];\n\n      if (isValidTarget(value) && !isTypeChecked(value)) {\n        target[name] = create(value, options);\n      }\n    }\n  }\n\n  return target;\n};\n\nexport default properties;\n"],"names":["defaultTypeChecker","getDefaultTypeChecker","Object","defineProperty","exports","value","hasOwn","has","target","property","Boolean","call","prototype","hasOwnProperty","getDefaultProxyConfig","config","getProxyConfigValue","key","info","required","actual","actualTypeString","errorReporter","ConsoleErrorReporter","getErrorReporter","enabled","isEnabled","INFO_KEY","Symbol","createChildrenCache","children","getTargetInfo","undefined","setTargetInfo","hasTargetInfo","storeChildInfo","cache","name","childInfo","storeChildInfoFrom","child","getChildInfo","mergeTargetInfo","targetInfo","sourceInfo","deep","checker","names","targetCache","sourceCache","mergeChildrenCache","mergeConfigs","error","TARGET_KEY","validTypes","isValidTarget","isTypeChecked","getTypeCheckedChild","createFn","result","getProperty","setProperty","callFunction","wrapWithProxy","Function","Proxy","functionProxy","objectProxy","createInfoFromOptions","createTargetInfo","init","create","options","isIgnoredProperty","getTargetProperty","getPropertyInit","Error","setNonTargetProperty","setTargetProperty","setPropertyInit","thisArg","argumentsList","arguments","length","index","String","getTargetArguments","apply","returnValue","callFunctionInit","deepInitializer","keys","forEach","typeChecker","newConfig","assign","action","requiredTypeString","console","warn","constructErrorString","reporter","sources","find","item","isFrozen","isSealed","writable","get","set","getOwnPropertyDescriptor"],"mappings":"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"}