{"version":3,"file":"type-checkers.min.js","sources":["../node_modules/@actualwave/closure-value/closure-value.js","../source/config/default-checker.js","../source/config/enabled.js","../node_modules/@actualwave/get-class/get-class.js","../source/config/ignored-classes.js","../source/config/wrap-config.js","../node_modules/@actualwave/path-sequence-to-string/index.js","../node_modules/@actualwave/has-own/has-own.js","../source/info/children.js","../source/info/target.js","../node_modules/@actualwave/is-function/is-function.js","../node_modules/@actualwave/with-proxy/with-proxy.js","../source/utils.js","../source/proxy/handlers/get.js","../source/proxy/handlers/set.js","../source/proxy/handlers/apply.js","../source/proxy/wrap.js","../source/proxy/handlers/construct.js","../source/proxy/handlers/deleteProperty.js","../source/proxy/wrapDeep.js","../source/object.js","../source/info/utils.js"],"sourcesContent":["'use strict';\n\nObject.defineProperty(exports, '__esModule', { value: true });\n\nconst singleValueFactory = (defaultValue = null, valueFormatter = (value) => value) => {\n  let value = defaultValue;\n\n  return {\n    getDefault: () => defaultValue,\n    get: () => value,\n    set: (newValue = defaultValue) => {\n      value = valueFormatter(newValue);\n    },\n  };\n};\n\nconst valuesMapFactory = (defaults = new Map(), valueFormatter = (key, value) => value) => {\n  const defaultValues = new Map(defaults);\n  const getDefault = () => new Map(defaultValues);\n\n  const values = getDefault();\n\n  return {\n    values,\n    getDefault,\n    copy: () => new Map(values),\n    delete: (key) => values.delete(key),\n    has: (key) => values.has(key),\n    set: (key, value) => values.set(key, valueFormatter(key, value)),\n    get: (key) => values.get(key),\n  };\n};\n\nconst valuesSetFactory = (defaults = new Set(), valueFormatter = (value) => value) => {\n  const defaultValues = new Set(defaults);\n  const getDefault = () => new Set(defaultValues);\n\n  const values = getDefault();\n\n  return {\n    values,\n    getDefault,\n    get: () => new Set(values),\n    delete: (value) => values.delete(value),\n    has: (value) => values.has(value),\n    add: (value) => values.add(valueFormatter(value)),\n  };\n};\n\nexports.singleValueFactory = singleValueFactory;\nexports.valuesMapFactory = valuesMapFactory;\nexports.valuesSetFactory = valuesSetFactory;","import { singleValueFactory } from '@actualwave/closure-value';\n\nexport const {\n  get: getDefaultTypeChecker,\n  set: setDefaultTypeChecker,\n} = singleValueFactory();\n","import { singleValueFactory } from '@actualwave/closure-value';\n\nexport const {\n  get: isEnabled,\n  set: setEnabled,\n} = singleValueFactory(true, (value) => !!value);\n","'use strict';\n\nObject.defineProperty(exports, '__esModule', { value: true });\n\nconst getClass = (target) => {\n  if(target === null || target === undefined) {\n    return undefined;\n  }\n  \n  const proto = Object.getPrototypeOf(target);\n  \n  if (typeof proto === 'object') {\n    return proto.constructor;\n  }\n\n  return proto;\n};\n\nconst getParentClass = (target) => {\n  const def = getClass(target);\n  \n  return def && Object.getPrototypeOf(def);\n};\n\nconst getClassName = (value) => {\n  if (!value) return '';\n\n  const match = String(getClass(value)).match(\n    /^(?:[^\\(\\{\\s]*)(?:class|function)\\s+([\\w\\d_$]+)(?:\\s*\\(|\\s*\\{|\\s+extends)/,\n  );\n\n  return match ? match[1] : '';\n};\n\nexports.getClassName = getClassName;\nexports.getParentClass = getParentClass;\nexports.getClass = getClass;\nexports.default = getClass;\n","import { getClass } from '@actualwave/get-class';\n\n/*\n When ignoring class, its instances will never be wrapped.\n*/\nconst constructors = new Set();\n\nexport const addIgnoredClasses = (...classes) => {\n  classes.forEach((constructor) => {\n    if (constructor && !constructors.has(constructor)) {\n      constructors.add(constructor);\n    }\n  });\n};\n\nexport const removeIgnoredClasses = (...classes) => {\n  classes.forEach((constructor) => constructors.delete(constructor));\n};\n\nexport const isIgnoredClass = (constructor) => constructors.has(constructor);\n\nexport const isValueOfIgnoredClass = (value) => constructors.has(getClass(value));\n\n/**\n * Number, String, Boolean and Symbol will not pass\n *\n *  typeof === 'object' || typeof === 'function'\n *\n * check, so not need to add them.\n */\naddIgnoredClasses(Map, Set, Date, Error);\n","import { valuesMapFactory } from '@actualwave/closure-value';\n\nexport const WRAP_FUNCTION_RETURN_VALUES = 'wrapFunctionReturnValues';\nexport const WRAP_FUNCTION_ARGUMENTS = 'wrapFunctionArguments';\nexport const WRAP_SET_PROPERTY_VALUES = 'wrapSetPropertyValues';\nexport const WRAP_IGNORE_PROTOTYPE_METHODS = 'ignorePrototypeMethods';\n\nconst { getDefault: getDefaultWrapConfig, set: setWrapConfigValue, get } = valuesMapFactory(\n  [\n    [WRAP_FUNCTION_RETURN_VALUES, true],\n    [WRAP_FUNCTION_ARGUMENTS, false],\n    [WRAP_SET_PROPERTY_VALUES, false],\n    [WRAP_IGNORE_PROTOTYPE_METHODS, false],\n  ],\n  (key, value) => !!value,\n);\n\nexport const getWrapConfigValue = (name, target) => {\n  let value;\n\n  if (target) {\n    value = target[name];\n  }\n\n  return value === undefined ? get(name) : value;\n};\n\nexport { getDefaultWrapConfig, setWrapConfigValue };\n","'use strict';\n\nObject.defineProperty(exports, '__esModule', { value: true });\n\n/**\n * Wrap any value with AsIs() to pass it to string as is without ant wrapping\n * or dot prior to name.\n * @param {*} value\n */\nfunction AsIs(value) {\n  if (this instanceof AsIs) {\n    this.value = value;\n  } else {\n    return new AsIs(value);\n  }\n}\n\nfunction asIs() {\n  return this.value;\n}\n\nAsIs.prototype.toString = asIs;\nAsIs.prototype.valueOf = asIs;\nAsIs.prototype[Symbol.toPrimitive] = asIs;\n\n/**\n *\n * @param {String} str\n * @param {String|AsIs|Number} name\n */\nconst appendPathNameToString = (str, name) => {\n  const string = String(str) || '';\n\n  if (name instanceof AsIs) {\n    return `${string}${name}`;\n  }\n\n  if (typeof name === 'symbol') {\n    return `${string}[${String(name)}]`;\n  }\n\n  if (String(parseInt(name, 10)) === name) {\n    return `${string}[${name}]`;\n  }\n\n  if (/^[a-z_$][\\w\\d$_]*$/i.test(name)) {\n    return string ? `${string}.${name}` : name;\n  }\n\n  return `${string}[\"${name}\"]`;\n};\n\nclass PathSequence {\n  constructor(value) {\n    this.value = value ? String(value) : '';\n    this.lastName = undefined;\n  }\n\n  append(name) {\n    this.value = appendPathNameToString(this.value, name);\n    this.lastName = name;\n  }\n\n  appendCustomValue(customString) {\n    this.value = appendPathNameToString(this.value, AsIs(customString));\n    this.lastName = customString;\n  }\n\n  clone(nextName = undefined) {\n    const sequence = new PathSequence(this.value);\n\n    if (nextName === undefined) {\n      sequence.lastName = this.lastName;\n    } else {\n      sequence.append(nextName);\n    }\n\n    return sequence;\n  }\n\n  getLastName() {\n    return this.lastName;\n  }\n\n  toString() {\n    return this.value;\n  }\n\n  valueOf() {\n    return this.value;\n  }\n}\n\n/**\n *\n * @returns {Array<String|Number|AsIs>}\n */\nconst createPathSequence = value => new PathSequence(value);\n\nexports.createPathSequence = createPathSequence;\nexports.default = PathSequence;\n//# sourceMappingURL=index.js.map\n","'use strict';\n\nObject.defineProperty(exports, '__esModule', { value: true });\n\nconst hasOwn = (\n  (has) =>\n  (target, property) =>\n  Boolean(target && has.call(target, property))\n)(Object.prototype.hasOwnProperty);\n\nexports.hasOwn = hasOwn;\nexports.default = hasOwn;","import hasOwn from '@actualwave/has-own';\n\n/*\n  I have had to apply custom key instead of name as is to\n  fix \"construtor\" issue. Since ordinary object has some\n  properties with values from start, these properties were\n  mustakenly returned as child info objects, for example, if\n  requesting hild info for \"constructor\" function of the target,\n  it returned class constructor which caused errors later,\n  when accesing info properties.\n\n  Converts Symbols and Numbers to String.\n\n  FIXME: Map might be fitting better.\n */\nconst getChildInfoKey = (name) => `@${String(name)}`;\n\nclass ChildrenCache {\n\n  constructor(children) {\n    if (children) {\n      this.cache = { ...children.cache };\n    } else {\n      this.cache = {};\n    }\n  }\n\n  store(name, childInfo) {\n    const key = getChildInfoKey(name);\n\n    if (childInfo) {\n      this.cache[key] = childInfo;\n    } else {\n      delete this.cache[key];\n    }\n  }\n\n  get(name) {\n    return this.cache[getChildInfoKey(name)];\n  }\n\n  has(name) {\n    return !!this.cache[getChildInfoKey(name)];\n  }\n\n  remove(cache, name) {\n    return delete this.cache[getChildInfoKey(name)];\n  }\n\n  copy({ cache: sourceCache }) {\n    Object.keys(sourceCache).forEach((key) => {\n      if (hasOwn(this.cache, key)) {\n        this.cache[key].copy(sourceCache[key]);\n      } else {\n        this.cache[key] = sourceCache[key];\n      }\n    });\n\n    return this;\n  }\n}\n\nexport const createChildrenCache = (children) => new ChildrenCache(children);\n\nexport default ChildrenCache;\n","import { createPathSequence } from '@actualwave/path-sequence-to-string';\n\nimport { createChildrenCache } from './children';\n\nexport const INFO_KEY = Symbol('type-checkers::info');\n\nexport const getTargetInfo = (target) => (target ? target[INFO_KEY] : undefined);\n\nexport const setTargetInfo = (target, info) => {\n  if (target && info) {\n    target[INFO_KEY] = info;\n  }\n};\n\nexport const removeTargetInfo = (target) => delete target[INFO_KEY];\n\nexport const hasTargetInfo = (target) => !!getTargetInfo(target);\n\nclass TargetInfo {\n  constructor(\n    checker,\n    data = null,\n    deep = true,\n    names = createPathSequence(),\n    children = createChildrenCache(),\n  ) {\n    this.checker = checker;\n    this.data = data;\n    this.deep = deep;\n    this.names = names;\n    this.children = children;\n  }\n\n  getChild(name) {\n    return this.children.get(name);\n  }\n\n  storeChildFrom(name, child) {\n    const info = getTargetInfo(child);\n\n    if (info) {\n      this.children.store(name, info);\n    }\n  }\n\n  createChildWithNames(names, value, data = null) {\n    const childInfo = new TargetInfo(\n      this.checker,\n      this.checker.init(value, data),\n      this.deep,\n      names,\n    );\n\n    this.children.store(names.lastName, childInfo);\n\n    return childInfo;\n  }\n\n  createChild(name, value, data = null) {\n    return this.createChildWithNames(this.names.clone(name), value, data);\n  }\n\n  copy({ deep, checker, children, data, names }) {\n    if (this.checker === checker) {\n      this.deep = this.deep || deep;\n      this.children.copy(children);\n      this.data = checker.mergeConfigs(this.data, data, names);\n    } else {\n      console.error(\n        'TypeChecked objects can be merged only if using exactly same instance of type checker.',\n      );\n    }\n\n    return this;\n  }\n}\n\nexport const createTargetInfo = (checker, data, deep, names, children) =>\n  new TargetInfo(checker, data, deep, names, children);\n","'use strict';\n\nObject.defineProperty(exports, '__esModule', { value: true });\n\nconst isFunction = (target) => (typeof target === 'function');\n\nexports.isFunction = isFunction;\nexports.default = isFunction;","'use strict';\n\nObject.defineProperty(exports, '__esModule', { value: true });\n\nconst { isFunction } = require('@actualwave/is-function');\n\nconst withProxy = (handlers) => {\n  /*\n   have problems with using rest operator here, when in node_modules without additional \n   configurations, so using old style code\n  */\n  const { apply, construct } = handlers;\n\n  delete handlers.apply;\n  delete handlers.construct;\n\n  const functionHandlers = { ...handlers, construct, apply };\n\n  return (target) => new Proxy(target, isFunction(target) ? functionHandlers : handlers);\n};\n\nexports.withProxy = withProxy;\nexports.default = withProxy;\n","import { isValueOfIgnoredClass } from './config/ignored-classes';\nimport { getTargetInfo } from './info';\nimport {\n  WRAP_FUNCTION_ARGUMENTS,\n  WRAP_FUNCTION_RETURN_VALUES,\n  WRAP_IGNORE_PROTOTYPE_METHODS,\n  WRAP_SET_PROPERTY_VALUES,\n} from './config/wrap-config';\n\nexport const TARGET_KEY = Symbol('type-checkers::target');\n\nexport const isSymbol = (value) => typeof value === 'symbol';\n\nexport const isOfWrappableType = (target) => {\n  const type = typeof target;\n\n  return (\n    Boolean(target) && (type === 'function' || type === 'object') && !isValueOfIgnoredClass(target)\n  );\n};\n\nexport const isWrapped = (target) => Boolean(target && target[TARGET_KEY]);\n\nexport const isWrappable = (target) => isOfWrappableType(target) && !isWrapped(target);\n\nexport const unwrap = (target) => (target && target[TARGET_KEY]) || target;\n\nexport const setWrapConfigTo = (target, key, value) => {\n  if (!isWrapped(target)) {\n    return false;\n  }\n\n  const info = getTargetInfo(target);\n\n  switch (key) {\n    case WRAP_FUNCTION_RETURN_VALUES:\n    case WRAP_FUNCTION_ARGUMENTS:\n    case WRAP_SET_PROPERTY_VALUES:\n    case WRAP_IGNORE_PROTOTYPE_METHODS:\n      info[key] = !!value;\n      return true;\n    default:\n      return false;\n  }\n};\n","import hasOwn from '@actualwave/has-own';\nimport isFunction from '@actualwave/is-function';\n\nimport { isWrappable, isSymbol, TARGET_KEY } from '../../utils';\nimport { INFO_KEY, getTargetInfo } from '../../info';\nimport { getWrapConfigValue, WRAP_IGNORE_PROTOTYPE_METHODS } from '../../config/wrap-config';\n\nconst getTargetProperty = (wrapFn, target, names, value) => {\n  const info = getTargetInfo(target);\n  const { deep } = info;\n\n  if (deep || isFunction(value)) {\n    const { lastName: property } = names;\n\n    const childInfo = info.getChild(property);\n\n    if (childInfo) {\n      return wrapFn(value, childInfo);\n    }\n\n    return wrapFn(value, info.createChildWithNames(names, value));\n  }\n\n  return value;\n};\n\n/**\n * Skips prototype methods if they are ignored by config\n */\nconst isIgnoredProperty = (target, info, property, value) => {\n  if (\n    isFunction(value) &&\n    !hasOwn(target, property) &&\n    getWrapConfigValue(WRAP_IGNORE_PROTOTYPE_METHODS, info)\n  ) {\n    return true;\n  }\n\n  return false;\n};\n\nconst getPropertyFactory = (wrapFn) => (target, property) => {\n  const value = target[property];\n\n  if (property === INFO_KEY) {\n    return value;\n    /*\n    target[TARGET_KEY] is a virtual property accessing which indicates\n    if object is wrapped with type checked proxy or not.\n    Also it allows \"unwrapping\" target.\n    */\n  }\n\n  if (property === TARGET_KEY) {\n    return target;\n  }\n\n  if (isSymbol(property)) {\n    return target[property];\n  }\n\n  const info = getTargetInfo(target);\n  const { names, data, checker } = info;\n\n  const nextNames = names.clone(property);\n\n  if (checker.getProperty) {\n    checker.getProperty(target, nextNames, value, data);\n  }\n\n  if (!isWrappable(value) || isIgnoredProperty(target, info, property, value)) {\n    return value;\n  }\n\n  return getTargetProperty(wrapFn, target, nextNames, value);\n};\n\nexport default getPropertyFactory;\n","import { INFO_KEY, getTargetInfo } from '../../info';\nimport { TARGET_KEY, isSymbol, isWrappable } from '../../utils';\nimport { getWrapConfigValue, WRAP_SET_PROPERTY_VALUES } from '../../config/wrap-config';\n\nconst setNonTargetProperty = (target, property, value) => {\n  const { names, data, checker } = getTargetInfo(target);\n\n  if (checker.setProperty) {\n    checker.setProperty(target, names.clone(property), value, data);\n  }\n\n  target[property] = value;\n\n  return true;\n};\n\nconst setTargetProperty = (wrapFn, target, property, value) => {\n  const info = getTargetInfo(target);\n  const { names, checker, data } = info;\n  const childInfo = info.getChild(property);\n  const nextNames = childInfo ? childInfo.names : names.clone(property);\n\n  if (checker.setProperty) {\n    checker.setProperty(target, nextNames, value, data);\n  }\n\n  if (childInfo) {\n    value = wrapFn(value, childInfo);\n  } else {\n    value = wrapFn(value, info.createChildWithNames(nextNames, value));\n  }\n\n  target[property] = value;\n  return true;\n};\n\nconst updateTargetInfo = (target, value) => {\n  let info = getTargetInfo(target);\n  if (info && value && info !== value) {\n    info.copy(value);\n  } else {\n    info = value;\n  }\n\n  target[INFO_KEY] = info;\n  return true;\n};\n\nconst setPropertyFactory = (wrapFn) => (target, property, value) => {\n  if (property === TARGET_KEY) {\n    throw new Error(`\"${TARGET_KEY}\" is a virtual property and cannot be set`);\n  }\n\n  if (property === INFO_KEY) {\n    return updateTargetInfo(target, value);\n  }\n\n  if (isSymbol(property)) {\n    return updateTargetInfo(target, value);\n  }\n\n  const info = getTargetInfo(target);\n\n  if (isWrappable(value) && getWrapConfigValue(WRAP_SET_PROPERTY_VALUES, info)) {\n    return setTargetProperty(wrapFn, target, property, value);\n  }\n\n  return setNonTargetProperty(target, property, value);\n};\n\nexport default setPropertyFactory;\n","import { getTargetInfo } from '../../info';\nimport { isWrappable } from '../../utils';\n\nimport {\n  getWrapConfigValue,\n  WRAP_FUNCTION_ARGUMENTS,\n  WRAP_FUNCTION_RETURN_VALUES,\n} from '../../config/wrap-config';\n\nexport const getTypeCheckedChild = (wrapFn, info, name, value) => {\n  if (!isWrappable(value)) {\n    return value;\n  }\n\n  const childInfo = info.getChild(name);\n\n  if (childInfo) {\n    return wrapFn(value, childInfo);\n  }\n\n  return wrapFn(value, info.createChild(name, value));\n};\n\nexport const getTargetArguments = (wrapFn, info, argumentsList) => {\n  if (getWrapConfigValue(WRAP_FUNCTION_ARGUMENTS, info)) {\n    const { length } = argumentsList;\n    for (let index = 0; index < length; index++) {\n      argumentsList[index] = getTypeCheckedChild(wrapFn, info, String(index), argumentsList[index]);\n    }\n  }\n\n  return argumentsList;\n};\n\nconst applyFunctionFactory = (wrapFn) => (target, thisArg, argumentsList) => {\n  const info = getTargetInfo(target);\n  const { names, data, checker } = info;\n\n  if (checker.arguments) {\n    checker.arguments(target, names, argumentsList, data, thisArg);\n  }\n\n  if (getWrapConfigValue(WRAP_FUNCTION_ARGUMENTS, info)) {\n    argumentsList = getTargetArguments(wrapFn, info, argumentsList);\n  }\n\n  let result = target.apply(thisArg, argumentsList);\n\n  if (checker.returnValue) {\n    checker.returnValue(target, names, result, data, thisArg);\n  }\n\n  if (getWrapConfigValue(WRAP_FUNCTION_RETURN_VALUES, info)) {\n    result = getTypeCheckedChild(wrapFn, info, 'returnValue', result);\n  }\n\n  return result;\n};\n\nexport default applyFunctionFactory;\n","/* eslint-disable import/prefer-default-export */\nimport withProxy from '@actualwave/with-proxy';\nimport { createPathSequence } from '@actualwave/path-sequence-to-string';\n\nimport { isWrappable } from '../utils';\nimport { setTargetInfo, createTargetInfo } from '../info';\nimport { isEnabled } from '../config/enabled';\nimport { getDefaultTypeChecker } from '../config/default-checker';\n\nimport getPropertyFactory from './handlers/get';\nimport setPropertyFactory from './handlers/set';\nimport applyFunctionFactory from './handlers/apply';\nimport constructFactory from './handlers/construct';\nimport deletePropertyFactory from './handlers/deleteProperty';\n\nexport const createInfoFromOptions = (\n  target,\n  {\n    checker = getDefaultTypeChecker(),\n    deep,\n    name,\n    data,\n    children,\n    info = null, // exclusive option, if set other options being ignored\n  } = {},\n) =>\n  info ||\n  createTargetInfo(checker, checker.init(target, data), deep, createPathSequence(name), children);\n\nconst generateHandlers = (create, config = null) => ({\n  get: (!config || config.get) && getPropertyFactory(create),\n  set: (!config || config.set) && setPropertyFactory(create),\n  apply: (!config || config.apply) && applyFunctionFactory(create),\n  construct: (!config || config.construct) && constructFactory(create),\n  deleteProperty: (!config || config.deleteProperty) && deletePropertyFactory(create),\n});\n\nexport const createWrapFactory = (proxyConfig) => {\n  let wrapInternal;\n  const assignInfoAndWrap = (target, info) => {\n    setTargetInfo(target, info);\n    return wrapInternal(target);\n  };\n\n  const handlers = generateHandlers(assignInfoAndWrap, proxyConfig);\n  wrapInternal = withProxy(handlers);\n\n  return assignInfoAndWrap;\n};\n\nexport const wrap = (target, options = null, proxyConfig = null) => {\n  if (!isWrappable(target) || !isEnabled()) {\n    return target;\n  }\n\n  const wrapInternal = createWrapFactory(proxyConfig);\n  const info = createInfoFromOptions(target, options || undefined);\n\n  return wrapInternal(target, info);\n};\n","import { getTargetInfo } from '../../info';\nimport {\n  getWrapConfigValue,\n  WRAP_FUNCTION_ARGUMENTS,\n  WRAP_FUNCTION_RETURN_VALUES,\n} from '../../config/wrap-config';\nimport { getTargetArguments, getTypeCheckedChild } from './apply';\n\nconst constructFactory = (wrapFn) => (Target, argumentsList) => {\n  const info = getTargetInfo(Target);\n  const { names, data, checker } = info;\n\n  if (checker.arguments) {\n    checker.arguments(Target, names, argumentsList, data);\n  }\n\n  if (getWrapConfigValue(WRAP_FUNCTION_ARGUMENTS, info)) {\n    argumentsList = getTargetArguments(wrapFn, info, argumentsList);\n  }\n\n  let result = new Target(...argumentsList);\n\n  if (checker.returnValue) {\n    checker.returnValue(Target, names, result, data);\n  }\n\n  if (getWrapConfigValue(WRAP_FUNCTION_RETURN_VALUES, info)) {\n    result = getTypeCheckedChild(wrapFn, info, 'returnValue', result);\n  }\n\n  return result;\n};\n\nexport default constructFactory;\n","import { INFO_KEY, getTargetInfo } from '../../info';\nimport { TARGET_KEY, isSymbol } from '../../utils';\n\nconst deletePropertyFactory = () => (target, property) => {\n  if (property === INFO_KEY) {\n    return delete target[property];\n  }\n\n  if (property === TARGET_KEY) {\n    return false;\n  }\n\n  if (isSymbol(property)) {\n    return delete target[property];\n  }\n\n  const info = getTargetInfo(target);\n  const { names, data, checker } = info;\n\n  checker.deleteProperty(target, names.clone(property), data);\n\n  return delete target[property];\n};\n\nexport default deletePropertyFactory;\n","/* eslint-disable import/prefer-default-export */\nimport { isEnabled } from '../config/enabled';\nimport { setTargetInfo } from '../info';\nimport { isWrappable } from '../utils';\nimport { createInfoFromOptions, createWrapFactory } from './wrap';\n\nconst deepInitializer = (target, info) => {\n  const { names, checker, data } = info;\n\n  Object.keys(target).forEach((name) => {\n    const value = target[name];\n    const nextNames = names.clone(name);\n\n    if (checker.getProperty) {\n      checker.getProperty(target, nextNames, value, data);\n    }\n\n    if (isWrappable(value)) {\n      let childInfo = info.getChild(name);\n\n      if (!childInfo) {\n        childInfo = info.createChildWithNames(nextNames, value);\n      }\n\n      deepInitializer(value, childInfo);\n    }\n  });\n\n  setTargetInfo(target, info);\n\n  return info;\n};\n\nexport const wrapDeep = (target, options, proxyConfig = null) => {\n  if (!isWrappable(target) || typeof target !== 'object' || !isEnabled()) {\n    return target;\n  }\n\n  const wrapInternal = createWrapFactory(proxyConfig);\n  const info = createInfoFromOptions(target, options);\n\n  deepInitializer(target, info);\n\n  return wrapInternal(target, info);\n};\n","import { wrap } from './proxy/wrap';\nimport { isWrapped } from './utils';\nimport { getTargetInfo } from './info';\n\nconst findWrapped = (list) => list.find(isWrapped);\n\n/**\n * Merge all objects and return new. If any of source objects were wrapped,\n * resulting object will be wrapped.\n * @param  {...any} sources\n */\nexport const merge = (...sources) => {\n  const wrapped = findWrapped(sources);\n\n  if (!wrapped) {\n    return Object.assign({}, ...sources);\n  }\n\n  const info = getTargetInfo(wrapped);\n\n  return Object.assign(wrap({}, { info }), ...sources);\n};\n\n/**\n * Calls merge() and forces wrapped result.\n * @param {*} options\n * @param  {...Object} sources\n */\nmerge.options = (options, ...sources) => merge(wrap({}, options), ...sources);\n\n/**\n * Assign properties from source objects to target. If target or any of sources\n * were wrapped, resulting object will be wrapped.\n * @param {*} target\n * @param  {...any} sources\n */\nexport const assign = (target, ...sources) => {\n  if (isWrapped(target)) {\n    return Object.assign(target, ...sources);\n  }\n\n  const wrapped = findWrapped(sources);\n\n  if (!wrapped) {\n    return Object.assign(target, ...sources);\n  }\n\n  const info = getTargetInfo(wrapped);\n\n  return Object.assign(wrap(target, { info }), ...sources);\n};\n\n/**\n * calls assign() and forces wrapped result.\n * @param {*} options\n * @param {Object} target\n * @param  {...Object} sources\n */\nassign.options = (options, target, ...sources) => assign(wrap(target, options), ...sources);\n","import { INFO_KEY } from './target';\n\nexport const getTypeChecker = (target) => {\n  if (target) {\n    const info = target[INFO_KEY];\n\n    return (info && info.checker) || undefined;\n  }\n\n  return undefined;\n};\n\nexport const getTypeCheckerData = (target) => {\n  if (target) {\n    const info = target[INFO_KEY];\n\n    return (info && info.data) || undefined;\n  }\n\n  return undefined;\n};\n"],"names":["Object","defineProperty","exports","value","defaultValue","valueFormatter","getDefault","get","set","newValue","defaults","Map","key","defaultValues","values","copy","delete","has","Set","add","getDefaultTypeChecker","setDefaultTypeChecker","singleValueFactory","isEnabled","setEnabled","getClass","target","proto","getPrototypeOf","constructor","match","String","def","constructors","addIgnoredClasses","classes","forEach","isValueOfIgnoredClass","Date","Error","getDefaultWrapConfig","setWrapConfigValue","valuesMapFactory","getWrapConfigValue","name","undefined","AsIs","this","asIs","prototype","toString","valueOf","Symbol","toPrimitive","appendPathNameToString","str","string","parseInt","test","PathSequence","[object Object]","lastName","customString","nextName","sequence","append","hasOwn","property","Boolean","call","hasOwnProperty","getChildInfoKey","ChildrenCache","children","cache","store","childInfo","remove","sourceCache","keys","createChildrenCache","INFO_KEY","getTargetInfo","setTargetInfo","info","TargetInfo","checker","data","deep","names","createPathSequence","getChild","storeChildFrom","child","createChildWithNames","init","createChild","clone","mergeConfigs","console","error","isFunction","require$$0","withProxy","handlers","apply","construct","functionHandlers","Proxy","TARGET_KEY","isSymbol","isWrapped","isWrappable","type","isOfWrappableType","getPropertyFactory","wrapFn","nextNames","getProperty","isIgnoredProperty","getTargetProperty","updateTargetInfo","setPropertyFactory","setProperty","setTargetProperty","setNonTargetProperty","getTypeCheckedChild","getTargetArguments","argumentsList","length","index","createInfoFromOptions","createTargetInfo","generateHandlers","create","config","thisArg","arguments","result","returnValue","applyFunctionFactory","Target","constructFactory","deleteProperty","deletePropertyFactory","createWrapFactory","proxyConfig","wrapInternal","assignInfoAndWrap","wrap","options","deepInitializer","findWrapped","list","find","merge","sources","wrapped","assign"],"mappings":"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"}