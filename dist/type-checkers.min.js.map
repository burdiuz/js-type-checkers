{"version":3,"file":"type-checkers.min.js","sources":["../source/checkers/utils.js","../source/checkers/primitive.js","../source/checkers/index.js","../source/reporters/utils.js","../source/reporters/console.js","../source/reporters/index.js","../source/enabled.js","../source/target/index.js","../source/proxy/config.js","../source/utils.js","../source/proxy/proxy.js","../source/reporters/error.js"],"sourcesContent":["\nexport const GET_PROPERTY = 'GetProperty';\nexport const SET_PROPERTY = 'SetProperty';\nexport const ARGUMENTS = 'Arguments';\nexport const RETURN_VALUE = 'ReturnValue';\nexport const MERGE = 'Merge';\n\nexport const buildPath = sequence => sequence\n  .reduce((str, name) => {\n    if (String(parseInt(name, 10)) === name) {\n      str = `${str}[${name}]`;\n    } else if (/^[a-z][\\w$]*$/i.test(name)) {\n      str = str ? `${str}.${name}` : name;\n    } else {\n      str = `${str}[\"${name}\"]`;\n    }\n\n    return str;\n  }, '');\n","import {\n  ARGUMENTS,\n  GET_PROPERTY,\n  RETURN_VALUE,\n  SET_PROPERTY,\n  MERGE,\n  buildPath,\n} from './utils';\n\nconst checkType = (action, types, name, type, errorReporter, sequence) => {\n  if (!type) {\n    return true;\n  }\n\n  const storedType = types[name];\n\n  if (storedType) {\n    // TODO add possibility to store function in types[name] that can be called to identify if there are type error\n    if (storedType !== type) {\n      errorReporter(action, buildPath([...sequence, name]), types[name], type);\n\n      return false;\n    }\n  } else {\n    types[name] = type;\n  }\n\n  return true;\n};\n\nconst PrimitiveTypeChecker = {\n  collectTypesOnInit: true,\n\n  init(target, errorReporter, cachedTypes = null) {\n    let types = {};\n\n    if (cachedTypes) {\n      types = cachedTypes;\n    } else if (this.collectTypesOnInit) {\n      Object.keys(target)\n        .forEach((key) => {\n          types[key] = this.getTypeString(target[key]);\n        });\n    }\n\n    return {\n      types,\n      errorReporter,\n    };\n  },\n\n  getTypeString(value) {\n    if (value === undefined) {\n      return '';\n    } else if (value instanceof Array) {\n      return 'array';\n    }\n\n    return typeof value;\n  },\n\n  mergeConfigs({ types, errorReporter }, source, names = []) {\n    const sourceTypes = source.types;\n\n    for (const name in sourceTypes) {\n      const sourceType = sourceTypes[name];\n      const targetType = types[name];\n      \n      if (sourceType && targetType && targetType !== sourceType) {\n        errorReporter(MERGE, buildPath([...names, name]), targetType, sourceType);\n      } else {\n        types[name] = sourceType;\n      }\n    }\n  },\n\n  getProperty(target, name, value, { types, errorReporter }, sequence) {\n    return checkType(\n      GET_PROPERTY,\n      types,\n      name,\n      this.getTypeString(value),\n      errorReporter,\n      sequence,\n    );\n  },\n\n  setProperty(target, name, newValue, { types, errorReporter }, sequence) {\n    return checkType(\n      SET_PROPERTY,\n      types,\n      name,\n      this.getTypeString(newValue),\n      errorReporter,\n      sequence,\n    );\n  },\n\n  arguments(target, thisArg, args, { types, errorReporter }, sequence) {\n    const { length } = args;\n    let valid = true;\n\n    for (let index = 0; index < length; index++) {\n      const agrValid = checkType(\n        ARGUMENTS,\n        types,\n        String(index),\n        this.getTypeString(args[index]),\n        errorReporter,\n        sequence,\n      );\n\n      valid = agrValid && valid;\n    }\n\n    return valid;\n  },\n\n  returnValue(target, thisArg, value, { types, errorReporter }, sequence) {\n    return checkType(\n      RETURN_VALUE,\n      types,\n      '',\n      this.getTypeString(value),\n      errorReporter,\n      sequence,\n    );\n  },\n};\n\nexport default PrimitiveTypeChecker;\n","import PrimitiveTypeChecker from './primitive';\n\nlet defaultTypeChecker = PrimitiveTypeChecker;\n\nexport const getDefaultTypeChecker = () => defaultTypeChecker;\nexport const setDefaultTypeChecker = (typeChecker) => defaultTypeChecker = typeChecker;\n","export const constructErrorString = (action, name, required, actual) =>\n  `${action}Error on \"${name}\" instead of \"${required}\" received \"${actual}\"`;\n","import { constructErrorString } from './utils';\n\nexport const ConsoleErrorReporter = (action, name, requiredTypeString, actualTypeString) =>\n  console.error(constructErrorString(action, name, requiredTypeString, actualTypeString));\n\nexport const ConsoleWarnReporter = (action, name, requiredTypeString, actualTypeString) =>\n  console.warn(constructErrorString(action, name, requiredTypeString, actualTypeString));\n","import { ConsoleErrorReporter } from './console';\n\nlet errorReporter = ConsoleErrorReporter;\n\nexport const getErrorReporter = () => errorReporter;\n\nexport const setErrorReporter = (reporter) => errorReporter = reporter;\n","let enabled = true;\n\nexport const isEnabled = () => enabled;\nexport const setEnabled = (value = true) => enabled = !!value;\n","export const INFO_KEY = Symbol('type-checkers::info');\n\nexport const createTargetInfo = (checker, config, deep = true, names = [], children = createChildrenCache()) => ({\n  checker,\n  config,\n  deep,\n  names,\n  children,\n});\nexport const getTargetInfo = (target) => target[INFO_KEY];\nexport const setTargetInfo = (target, info) => target[INFO_KEY] = info;\nexport const getTargetTypeChecker = (target) => getTargetInfo(target).checker;\nexport const getTargetTypeCheckerConfig = (target) => getTargetInfo(target).config;\n\nexport const createChildrenCache = (children = {}) => ({ ...children });\n\nexport const mergeChildrenCache = (targetCache, sourceCache) => {\n  for (const name in sourceCache) {\n    if (targetCache.hasOwnProperty(name)) {\n      targetCache[name] = mergeTargetInfo(targetCache[name], sourceCache[name]);\n    } else {\n      targetCache[name] = sourceCache[name];\n    }\n  }\n\n  return targetCache;\n};\n\nexport const storeChildInfo = (cache, name, childInfo) => {\n  // FIXME shoud it merge or just reassign?\n  cache[name] = childInfo;\n};\n\nexport const storeChildInfoFrom = (cache, name, child) => {\n  storeChildInfo(cache, name, getTargetInfo(child));\n};\n\nexport const getChildInfo = (cache, name) => cache[name];\n\nexport const removeChildInfo = (cache, name) => delete cache[name];\n\nexport const mergeTargetInfo = (targetInfo, sourceInfo) => {\n  const { checker, children, config, names } = targetInfo;\n\n  if (checker === sourceInfo.checker) {\n    targetInfo.children = mergeChildrenCache(children, sourceInfo.children);\n    targetInfo.config = checker.mergeConfigs(config, sourceInfo.config, names);\n  } else {\n    console.error('TypeChecked objects can be merged only if using exactly same instance of type checker.');\n  }\n\n  return targetInfo;\n};\n\nexport const assignTargetInfo = (targetInfo, ...sourceInfo) => {\n  const { length } = sourceInfo;\n\n  for (let index = 0; index < length; index++) {\n    const item = sourceInfo[index];\n\n    if (item) {\n      if (targetInfo) {\n        targetInfo = mergeTargetInfo(targetInfo, item);\n      } else {\n        targetInfo = item;\n      }\n    }\n  }\n\n  return targetInfo;\n};\n\nexport const assignTargetInfoFrom = (target, ...sources) => {\n  const { length } = sources;\n  let targetInfo = getTargetInfo(target);\n\n  for (let index = 0; index < length; index++) {\n    const sourceInfo = sources[index];\n\n    if (sourceInfo) {\n      if (targetInfo) {\n        targetInfo = mergeTargetInfo(targetInfo, sourceInfo);\n      } else {\n        targetInfo = sourceInfo;\n      }\n    }\n  }\n\n  setTargetInfo(target, targetInfo);\n  return target;\n};\n","export const config = {\n  wrapFunctionReturnValues: true,\n  wrapFunctionArguments: false,\n  wrapSetPropertyValues: true,\n};\n\nexport const setProxyConfig = (newConfig) => Object.assign(config, newConfig);\n\nexport const getProxyConfig = () => ({ ...config });\n","import { getTargetInfo } from './target';\n\nconst validTypes = {\n    object: true,\n    function: true,\n};\n\nexport const isValidTarget = (target) => target && validTypes[typeof target];\nexport const isTypeChecked = (target) => !!getTargetInfo(target);","import { getDefaultTypeChecker } from '../checkers';\nimport { getErrorReporter } from '../reporters';\nimport { isEnabled } from '../enabled';\nimport {\n  INFO_KEY,\n  createTargetInfo,\n  getTargetInfo,\n  setTargetInfo,\n  createChildrenCache,\n  getChildInfo,\n  storeChildInfoFrom,\n  removeChildInfo,\n} from '../target';\nimport { config as proxyConfig } from './config';\nimport { isValidTarget, isTypeChecked } from '../utils';\nimport { RETURN_VALUE } from '../checkers/utils';\n\nconst getProperty = (target, property) => {\n  let value = target[property];\n\n  if (property === INFO_KEY) {\n    return value;\n  }\n\n  const info = getTargetInfo(target);\n  const { deep, names, config, checker } = info;\n\n  checker.getProperty\n    && checker.getProperty(target, property, value, config, names);\n\n  if (!isValidTarget(value) || isTypeChecked(value)) {\n    return value;\n  }\n\n  if (deep || value instanceof Function) {\n    const { children } = info;\n    const childInfo = getChildInfo(children, name);\n\n    if (childInfo) {\n      value = create(value, { info: childInfo }, checker);\n    } else {\n      value = create(value, { deep, names: [...names, property] }, checker);\n      storeChildInfoFrom(children, name, value);\n    }\n  }\n\n  return value;\n};\n\nconst setProperty = (target, property, value) => {\n  const info = getTargetInfo(target);\n  const { deep, names, config, checker } = info;\n\n  if (property !== INFO_KEY) {\n    checker.setProperty\n      && checker.setProperty(target, property, value, config, names);\n\n    if (proxyConfig.wrapSetPropertyValues) {\n      const { children } = info;\n\n      if (!isTypeChecked(value)) {\n        const childInfo = getChildInfo(children, name);\n\n        if (childInfo) {\n          value = create(value, { info: childInfo }, checker);\n        } else {\n          value = create(value, { deep, names: [...names, property] }, checker);\n        }\n      }\n\n      storeChildInfoFrom(children, name, value);\n    }\n  }\n\n  target[property] = value;\n};\n\nconst callFunction = (target, thisArg, argumentsList) => {\n  const info = getTargetInfo(target);\n  const { deep, names, config, checker } = info;\n\n  checker.arguments\n    && checker.arguments(target, thisArg, argumentsList, config, names);\n\n  if (proxyConfig.wrapFunctionArguments) {\n    const { length } = argumentsList;\n    for (let index = 0; index < length; index++) {\n      argumentsList[index] = create(argumentsList[index], { deep, names: [...names, index] }, checker);\n    }\n  }\n\n  let result = target.apply(thisArg, argumentsList);\n\n  checker.returnValue\n    && checker.returnValue(target, thisArg, result, config, names);\n\n  if (proxyConfig.wrapFunctionReturnValues) {\n    const { children } = info;\n\n    if (!isTypeChecked(result)) {\n      const childInfo = getChildInfo(children, RETURN_VALUE);\n\n      if (childInfo) {\n        result = create(result, { info: childInfo }, checker);\n      } else {\n        result = create(result, { deep, names: [...names] }, checker)\n      }\n    }\n\n    storeChildInfoFrom(children, RETURN_VALUE, result);\n  }\n  return result;\n};\n\nconst objectProxy = (target) => new Proxy(\n  target,\n  {\n    get: getProperty,\n    set: setProperty,\n  },\n);\n\nconst functionProxy = (target) => new Proxy(\n  target,\n  {\n    apply: callFunction,\n    construct: callFunction,\n  },\n);\n\nexport const create = (\n  target,\n  {\n    deep = true,\n    names = [],\n    config = null,\n    children = null,\n    info = null, // exclusive option, if set other options being ignored\n  } = {},\n  checker = getDefaultTypeChecker(),\n) => {\n  if (!isValidTarget(target) || !isEnabled() || isTypeChecked(target)) {\n    return target;\n  }\n\n  setTargetInfo(\n    target,\n    info || createTargetInfo(\n      checker,\n      checker.init(target, getErrorReporter(), config),\n      deep,\n      names,\n      createChildrenCache(children),\n    ),\n  );\n\n  if (target instanceof Function) {\n    return functionProxy(target);\n  }\n\n  return objectProxy(target);\n};\n\nexport const createDeep = () => {\n  // FIXME add new factory function createDeep, it will have deep == true by default and init type checkers for all internal objects \n  // and functions by reassigning original values with type checked proxies\n  // when creating checkers for children objects should check cached info\n};","import { constructErrorString } from './utils';\n\nexport const ThrowErrorReporter = (action, name, requiredTypeString, actualTypeString) => {\n  throw new Error(constructErrorString(action, name, requiredTypeString, actualTypeString));\n};\n"],"names":["RETURN_VALUE","buildPath","sequence","reduce","str","name","String","parseInt","test","action","types","type","errorReporter","storedType","defaultTypeChecker","target","cachedTypes","this","collectTypesOnInit","keys","forEach","key","getTypeString","value","undefined","Array","source","names","sourceTypes","sourceType","targetType","checkType","newValue","thisArg","args","length","valid","index","getDefaultTypeChecker","constructErrorString","required","actual","actualTypeString","ConsoleErrorReporter","getErrorReporter","enabled","isEnabled","INFO_KEY","Symbol","getTargetInfo","setTargetInfo","info","createChildrenCache","children","storeChildInfoFrom","cache","child","childInfo","getChildInfo","mergeTargetInfo","targetInfo","sourceInfo","checker","config","targetCache","sourceCache","hasOwnProperty","mergeChildrenCache","mergeConfigs","error","validTypes","isValidTarget","isTypeChecked","getProperty","property","deep","Function","create","setProperty","proxyConfig","wrapSetPropertyValues","callFunction","argumentsList","arguments","wrapFunctionArguments","result","apply","returnValue","wrapFunctionReturnValues","createTargetInfo","init","Proxy","typeChecker","requiredTypeString","console","warn","Error","reporter","item","sources","newConfig","Object","assign"],"mappings":"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"}