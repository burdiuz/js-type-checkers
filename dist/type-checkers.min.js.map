{"version":3,"file":"type-checkers.min.js","sources":["../node_modules/@actualwave/has-own/has-own.js","../source/config/utils.js","../source/config/default-checker.js","../source/config/enabled.js","../node_modules/@actualwave/get-class/get-class.js","../source/config/ignored-classes.js","../source/config/wrap-config.js","../node_modules/@actualwave/path-sequence-to-string/index.js","../source/info/children.js","../source/info/target.js","../node_modules/@actualwave/is-function/is-function.js","../node_modules/@actualwave/with-proxy/with-proxy.js","../source/utils.js","../source/proxy/handlers/get.js","../source/proxy/handlers/set.js","../source/proxy/handlers/apply.js","../source/proxy/wrap.js","../source/proxy/handlers/construct.js","../source/proxy/handlers/deleteProperty.js","../source/proxy/wrapDeep.js","../source/info/utils.js"],"sourcesContent":["'use strict';\n\nObject.defineProperty(exports, '__esModule', { value: true });\n\nconst hasOwn = (\n  (has) =>\n  (target, property) =>\n  Boolean(target && has.call(target, property))\n)(Object.prototype.hasOwnProperty);\n\nexports.hasOwn = hasOwn;\nexports.default = hasOwn;","import hasOwn from '@actualwave/has-own';\r\n\r\nexport const singleConfigFactory = (defaultValue = null, validator = undefined) => {\r\n  let value = defaultValue;\r\n\r\n  return {\r\n    get: () => value,\r\n    set: (newValue = defaultValue) => {\r\n      if (validator) {\r\n        value = validator(newValue);\r\n      } else {\r\n        value = newValue;\r\n      }\r\n    },\r\n  };\r\n};\r\n\r\nexport const mapConfigFactory = (defaultValues = {}, validator = undefined) => {\r\n  const getDefault = () => ({ ...defaultValues });\r\n\r\n  const values = getDefault();\r\n\r\n  return {\r\n    values,\r\n    getDefault,\r\n    set: (newValues) => Object.assign(values, validator ? validator(newValues) : newValues),\r\n    get: () => ({ ...values }),\r\n    getValue: (key) => (hasOwn(values, key) ? values[key] : undefined),\r\n  };\r\n};\r\n","import { singleConfigFactory } from './utils';\n\nexport const {\n  get: getDefaultTypeChecker,\n  set: setDefaultTypeChecker,\n} = singleConfigFactory();\n","import { singleConfigFactory } from './utils';\n\nexport const {\n  get: isEnabled,\n  set: setEnabled,\n} = singleConfigFactory(true, (value) => !!value);\n","'use strict';\n\nObject.defineProperty(exports, '__esModule', { value: true });\n\nconst getClass = (target) => {\n  if(target === null || target === undefined) {\n    return undefined;\n  }\n  \n  const proto = Object.getPrototypeOf(target);\n  \n  if (typeof proto === 'object') {\n    return proto.constructor;\n  }\n\n  return proto;\n};\n\nconst getParentClass = (target) => {\n  const def = getClass(target);\n  \n  return def && Object.getPrototypeOf(def);\n};\n\nconst getClassName = (value) => {\n  if (!value) return '';\n\n  const match = String(getClass(value)).match(\n    /^(?:[^\\(\\{\\s]*)(?:class|function)\\s+([\\w\\d_$]+)(?:\\s*\\(|\\s*\\{|\\s+extends)/,\n  );\n\n  return match ? match[1] : '';\n};\n\nexports.getClassName = getClassName;\nexports.getParentClass = getParentClass;\nexports.getClass = getClass;\nexports.default = getClass;\n","import { getClass } from '@actualwave/get-class';\n\n/*\n When ignoring class, its instances will never be wrapped.\n*/\nconst constructors = new Set();\n\nexport const addIgnoredClasses = (...classes) => {\n  classes.forEach((constructor) => {\n    if (constructor && !constructors.has(constructor)) {\n      constructors.add(constructor);\n    }\n  });\n};\n\nexport const removeIgnoredClasses = (...classes) => {\n  classes.forEach((constructor) => constructors.delete(constructor));\n};\n\nexport const isIgnoredClass = (constructor) => constructors.has(constructor);\n\nexport const isValueOfIgnoredClass = (value) => constructors.has(getClass(value));\n\n/**\n * Number, String, Boolean and Symbol will not pass\n *\n *  typeof === 'object' || typeof === 'function'\n *\n * check, so not need to add them.\n */\naddIgnoredClasses(Map, Set, Date, Error);\n","import { mapConfigFactory } from './utils';\n\nexport const WRAP_FUNCTION_RETURN_VALUES = 'wrapFunctionReturnValues';\nexport const WRAP_FUNCTION_ARGUMENTS = 'wrapFunctionArguments';\nexport const WRAP_SET_PROPERTY_VALUES = 'wrapSetPropertyValues';\nexport const WRAP_IGNORE_PROTOTYPE_METHODS = 'ignorePrototypeMethods';\n\nconst {\n  values,\n  getDefault: getDefaultWrapConfig,\n  get: getWrapConfig,\n  set: setWrapConfig,\n  getValue,\n} = mapConfigFactory(\n  {\n    [WRAP_FUNCTION_RETURN_VALUES]: true,\n    [WRAP_FUNCTION_ARGUMENTS]: false,\n    [WRAP_SET_PROPERTY_VALUES]: false,\n    [WRAP_IGNORE_PROTOTYPE_METHODS]: false,\n  },\n  (newValues) =>\n    Object.keys(newValues).forEach((key) => {\n      newValues[key] = !!newValues[key];\n    }),\n);\n\nexport const getWrapConfigInternal = () => values;\n\nexport const getWrapConfigValue = (name, target) => {\n  let value = target[name];\n\n  if (target) {\n    value = target[name];\n  }\n\n  return value === undefined ? getValue(name) : value;\n};\n\nexport { getDefaultWrapConfig, getWrapConfig, setWrapConfig };\n","'use strict';\n\nObject.defineProperty(exports, '__esModule', { value: true });\n\n/**\n * Wrap any value with AsIs() to pass it to string as is without ant wrapping\n * or dot prior to name.\n * @param {*} value\n */\nfunction AsIs(value) {\n  if (this instanceof AsIs) {\n    this.value = value;\n  } else {\n    return new AsIs(value);\n  }\n}\n\nfunction asIs() {\n  return this.value;\n}\n\nAsIs.prototype.toString = asIs;\nAsIs.prototype.valueOf = asIs;\nAsIs.prototype[Symbol.toPrimitive] = asIs;\n\n/**\n *\n * @param {String} str\n * @param {String|AsIs|Number} name\n */\nconst appendPathNameToString = (str, name) => {\n  const string = String(str) || '';\n\n  if (name instanceof AsIs) {\n    return `${string}${name}`;\n  }\n\n  if (typeof name === 'symbol') {\n    return `${string}[${name}]`;\n  }\n\n  if (String(parseInt(name, 10)) === name) {\n    return `${string}[${name}]`;\n  }\n\n  if (/^[a-z_$][\\w\\d$_]*$/i.test(name)) {\n    return string ? `${string}.${name}` : name;\n  }\n\n  return `${string}[\"${name}\"]`;\n};\n\nclass PathSequence {\n  constructor(value) {\n    this.value = value ? String(value) : '';\n    this.lastName = undefined;\n  }\n\n  append(name) {\n    this.value = appendPathNameToString(this.value, name);\n    this.lastName = name;\n  }\n\n  appendCustomValue(customString) {\n    this.value = appendPathNameToString(this.value, AsIs(customString));\n    this.lastName = customString;\n  }\n\n  clone(nextName = undefined) {\n    const sequence = new PathSequence(this.value);\n\n    if (nextName === undefined) {\n      sequence.lastName = this.lastName;\n    } else {\n      sequence.append(nextName);\n    }\n\n    return sequence;\n  }\n\n  getLastName() {\n    return this.lastName;\n  }\n\n  toString() {\n    return this.value;\n  }\n\n  valueOf() {\n    return this.value;\n  }\n}\n\n/**\n *\n * @returns {Array<String|Number|AsIs>}\n */\nconst createPathSequence = value => new PathSequence(value);\n\nexports.createPathSequence = createPathSequence;\nexports.default = PathSequence;\n//# sourceMappingURL=index.js.map\n","import hasOwn from '@actualwave/has-own';\n\n/*\n  I have had to apply custom key instead of name as is to\n  fix \"construtor\" issue. Since ordinary object has some\n  properties with values from start, these properties were\n  mustakenly returned as child info objects, for example, if\n  requesting hild info for \"constructor\" function of the target,\n  it returned class constructor which caused errors later,\n  when accesing info properties.\n */\nconst getChildInfoKey = (name) => `@${name}`;\n\nclass ChildrenCache {\n\n  constructor(children) {\n    if (children) {\n      this.cache = { ...children.cache };\n    } else {\n      this.cache = {};\n    }\n  }\n\n  store(name, childInfo) {\n    const key = getChildInfoKey(name);\n\n    if (childInfo) {\n      this.cache[key] = childInfo;\n    } else {\n      delete this.cache[key];\n    }\n  }\n\n  get(name) {\n    return this.cache[getChildInfoKey(name)];\n  }\n\n  has(name) {\n    return !!this.cache[getChildInfoKey(name)];\n  }\n\n  remove(cache, name) {\n    return delete this.cache[getChildInfoKey(name)];\n  }\n\n  copy({ cache: sourceCache }) {\n    Object.keys(sourceCache).forEach((key) => {\n      if (hasOwn(this.cache, key)) {\n        this.cache[key].copy(sourceCache[key]);\n      } else {\n        this.cache[key] = sourceCache[key];\n      }\n    });\n\n    return this;\n  }\n}\n\nexport const createChildrenCache = (children) => new ChildrenCache(children);\n\nexport default ChildrenCache;\n","import { createPathSequence } from '@actualwave/path-sequence-to-string';\n\nimport { createChildrenCache } from './children';\n\nexport const INFO_KEY = Symbol('type-checkers::info');\n\nexport const getTargetInfo = (target) => (target ? target[INFO_KEY] : undefined);\n\nexport const setTargetInfo = (target, info) => {\n  if (target && info) {\n    target[INFO_KEY] = info;\n  }\n};\n\nexport const removeTargetInfo = (target) => delete target[INFO_KEY];\n\nexport const hasTargetInfo = (target) => !!getTargetInfo(target);\n\nclass TargetInfo {\n  constructor(\n    checker,\n    data = null,\n    deep = true,\n    names = createPathSequence(),\n    children = createChildrenCache(),\n  ) {\n    this.checker = checker;\n    this.data = data;\n    this.deep = deep;\n    this.names = names;\n    this.children = children;\n  }\n\n  getChild(name) {\n    return this.children.get(name);\n  }\n\n  storeChildFrom(name, child) {\n    const info = getTargetInfo(child);\n\n    if (info) {\n      this.children.store(name, info);\n    }\n  }\n\n  createChildWithNames(names, value, data = null) {\n    const childInfo = new TargetInfo(\n      this.checker,\n      this.checker.init(value, data),\n      this.deep,\n      names,\n    );\n\n    this.children.store(names.lastName, childInfo);\n\n    return childInfo;\n  }\n\n  createChild(name, value, data = null) {\n    return this.createChildWithNames(this.names.clone(name), value, data);\n  }\n\n  copy({ deep, checker, children, data, names }) {\n    if (this.checker === checker) {\n      this.deep = this.deep || deep;\n      this.children.copy(children);\n      this.data = checker.mergeConfigs(this.data, data, names);\n    } else {\n      console.error(\n        'TypeChecked objects can be merged only if using exactly same instance of type checker.',\n      );\n    }\n\n    return this;\n  }\n}\n\nexport const createTargetInfo = (checker, data, deep, names, children) =>\n  new TargetInfo(checker, data, deep, names, children);\n","'use strict';\n\nObject.defineProperty(exports, '__esModule', { value: true });\n\nconst isFunction = (target) => (typeof target === 'function');\n\nexports.isFunction = isFunction;\nexports.default = isFunction;","'use strict';\n\nObject.defineProperty(exports, '__esModule', { value: true });\n\nconst { isFunction } = require('@actualwave/is-function');\n\nconst withProxy = (handlers) => {\n  /*\n   have problems with using rest operator here, when in node_modules without additional \n   configurations, so using old style code\n  */\n  const { apply, construct } = handlers;\n\n  delete handlers.apply;\n  delete handlers.construct;\n\n  const functionHandlers = { ...handlers, construct, apply };\n\n  return (target) => new Proxy(target, isFunction(target) ? functionHandlers : handlers);\n};\n\nexports.withProxy = withProxy;\nexports.default = withProxy;\n","import hasOwn from '@actualwave/has-own';\n\nimport { isValueOfIgnoredClass } from './config/ignored-classes';\nimport { getTargetInfo } from './info';\nimport {\n  WRAP_FUNCTION_ARGUMENTS,\n  WRAP_FUNCTION_RETURN_VALUES,\n  WRAP_IGNORE_PROTOTYPE_METHODS,\n  WRAP_SET_PROPERTY_VALUES,\n} from './config/wrap-config';\n\nexport const TARGET_KEY = Symbol('type-checkers::target');\n\nexport const isOfWrappableType = (target) => {\n  const type = typeof target;\n\n  return (\n    Boolean(target)\n    && (type === 'function' || type === 'object')\n    && !isValueOfIgnoredClass(target)\n  );\n};\n\nexport const isWrapped = (target) => Boolean(target && target[TARGET_KEY]);\n\nexport const isWrappable = (target) => isOfWrappableType(target) && !isWrapped(target);\n\nexport const unwrap = (target) => (target && target[TARGET_KEY]) || target;\n\nconst wrapConfigKeys = [\n  WRAP_FUNCTION_ARGUMENTS,\n  WRAP_FUNCTION_RETURN_VALUES,\n  WRAP_IGNORE_PROTOTYPE_METHODS,\n  WRAP_SET_PROPERTY_VALUES,\n];\n\nexport const setWrapConfigTo = (target, config) => {\n  if (!isWrapped(target) || !config) {\n    return;\n  }\n\n  const info = getTargetInfo(target);\n\n  wrapConfigKeys.forEach((key) => {\n    if (hasOwn(key, config)) {\n      info[key] = config[key];\n    }\n  });\n};\n","import hasOwn from '@actualwave/has-own';\nimport isFunction from '@actualwave/is-function';\n\nimport { isWrappable, TARGET_KEY } from '../../utils';\nimport { INFO_KEY, getTargetInfo } from '../../info';\nimport { getWrapConfigValue, WRAP_IGNORE_PROTOTYPE_METHODS } from '../../config/wrap-config';\n\nconst getTargetProperty = (wrapFn, target, names, value) => {\n  const info = getTargetInfo(target);\n  const { deep } = info;\n\n  if (deep || isFunction(value)) {\n    const { lastName: property } = names;\n\n    const childInfo = info.getChild(property);\n\n    if (childInfo) {\n      return wrapFn(value, childInfo);\n    }\n\n    return wrapFn(value, info.createChildWithNames(names, value));\n  }\n\n  return value;\n};\n\n/**\n * Skips prototype methods if they are ignored by config\n */\nconst isIgnoredProperty = (target, info, property, value) => {\n  if (\n    isFunction(value) &&\n    !hasOwn(target, property) &&\n    getWrapConfigValue(WRAP_IGNORE_PROTOTYPE_METHODS, info)\n  ) {\n    return true;\n  }\n\n  return false;\n};\n\nconst getPropertyFactory = (wrapFn) => (target, property) => {\n  const value = target[property];\n\n  if (property === INFO_KEY) {\n    return value;\n    /*\n    target[TARGET_KEY] is a virtual property accessing which indicates\n    if object is wrapped with type checked proxy or not.\n    Also it allows \"unwrapping\" target.\n    */\n  } else if (property === TARGET_KEY) {\n    return target;\n  }\n\n  const info = getTargetInfo(target);\n  const { names, data, checker } = info;\n\n  const nextNames = names.clone(property);\n\n  if (checker.getProperty) {\n    checker.getProperty(target, nextNames, value, data);\n  }\n\n  if (!isWrappable(value) || isIgnoredProperty(target, info, property, value)) {\n    return value;\n  }\n\n  return getTargetProperty(wrapFn, target, nextNames, value);\n};\n\nexport default getPropertyFactory;\n","import { INFO_KEY, getTargetInfo } from '../../info';\nimport { TARGET_KEY, isWrappable } from '../../utils';\nimport { getWrapConfigValue, WRAP_SET_PROPERTY_VALUES } from '../../config/wrap-config';\n\nconst setNonTargetProperty = (target, property, value) => {\n  const { names, data, checker } = getTargetInfo(target);\n\n  if (checker.setProperty) {\n    checker.setProperty(target, names.clone(property), value, data);\n  }\n\n  target[property] = value;\n\n  return true;\n};\n\nconst setTargetProperty = (wrapFn, target, property, value) => {\n  const info = getTargetInfo(target);\n  const { names, checker, data } = info;\n  const childInfo = info.getChild(property);\n  const nextNames = childInfo ? childInfo.names : names.clone(property);\n\n  if (checker.setProperty) {\n    checker.setProperty(target, nextNames, value, data);\n  }\n\n  if (childInfo) {\n    value = wrapFn(value, childInfo);\n  } else {\n    value = wrapFn(value, info.createChildWithNames(nextNames, value));\n  }\n\n  target[property] = value;\n  return true;\n};\n\nconst updateTargetInfo = (target, value) => {\n  let info = getTargetInfo(target);\n  if (info && value && info !== value) {\n    info.copy(value);\n  } else {\n    info = value;\n  }\n\n  target[INFO_KEY] = info;\n  return true;\n};\n\nconst setPropertyFactory = (wrapFn) => (target, property, value) => {\n  if (property === TARGET_KEY) {\n    throw new Error(`\"${TARGET_KEY}\" is a virtual property and cannot be set`);\n  }\n\n  if (property === INFO_KEY) {\n    return updateTargetInfo(target, value);\n  }\n\n  const info = getTargetInfo(target);\n\n  if (isWrappable(value) && getWrapConfigValue(WRAP_SET_PROPERTY_VALUES, info)) {\n    return setTargetProperty(wrapFn, target, property, value);\n  }\n\n  return setNonTargetProperty(target, property, value);\n};\n\nexport default setPropertyFactory;\n","import { getTargetInfo } from '../../info';\nimport { isWrappable } from '../../utils';\n\nimport {\n  getWrapConfigValue,\n  WRAP_FUNCTION_ARGUMENTS,\n  WRAP_FUNCTION_RETURN_VALUES,\n} from '../../config/wrap-config';\n\nexport const getTypeCheckedChild = (wrapFn, info, name, value) => {\n  if (!isWrappable(value)) {\n    return value;\n  }\n\n  const childInfo = info.getChild(name);\n\n  if (childInfo) {\n    return wrapFn(value, childInfo);\n  }\n\n  return wrapFn(value, info.createChild(name, value));\n};\n\nexport const getTargetArguments = (wrapFn, info, argumentsList) => {\n  if (getWrapConfigValue(WRAP_FUNCTION_ARGUMENTS, info)) {\n    const { length } = argumentsList;\n    for (let index = 0; index < length; index++) {\n      argumentsList[index] = getTypeCheckedChild(wrapFn, info, String(index), argumentsList[index]);\n    }\n  }\n\n  return argumentsList;\n};\n\nconst applyFunctionFactory = (wrapFn) => (target, thisArg, argumentsList) => {\n  const info = getTargetInfo(target);\n  const { names, data, checker } = info;\n\n  if (checker.arguments) {\n    checker.arguments(target, names, argumentsList, data, thisArg);\n  }\n\n  if (getWrapConfigValue(WRAP_FUNCTION_ARGUMENTS, info)) {\n    argumentsList = getTargetArguments(wrapFn, info, argumentsList);\n  }\n\n  let result = target.apply(thisArg, argumentsList);\n\n  if (checker.returnValue) {\n    checker.returnValue(target, names, result, data, thisArg);\n  }\n\n  if (getWrapConfigValue(WRAP_FUNCTION_RETURN_VALUES, info)) {\n    result = getTypeCheckedChild(wrapFn, info, 'returnValue', result);\n  }\n\n  return result;\n};\n\nexport default applyFunctionFactory;\n","/* eslint-disable import/prefer-default-export */\r\nimport withProxy from '@actualwave/with-proxy';\r\nimport { createPathSequence } from '@actualwave/path-sequence-to-string';\r\n\r\nimport { isWrappable } from '../utils';\r\nimport { setTargetInfo, createTargetInfo } from '../info';\r\nimport { isEnabled } from '../config/enabled';\r\nimport { getDefaultTypeChecker } from '../config/default-checker';\r\n\r\nimport getPropertyFactory from './handlers/get';\r\nimport setPropertyFactory from './handlers/set';\r\nimport applyFunctionFactory from './handlers/apply';\r\nimport constructFactory from './handlers/construct';\r\nimport deletePropertyFactory from './handlers/deleteProperty';\r\n\r\nexport const createInfoFromOptions = (\r\n  target,\r\n  {\r\n    checker = getDefaultTypeChecker(),\r\n    deep,\r\n    name,\r\n    data,\r\n    children,\r\n    info = null, // exclusive option, if set other options being ignored\r\n  } = {},\r\n) =>\r\n  info ||\r\n  createTargetInfo(checker, checker.init(target, data), deep, createPathSequence(name), children);\r\n\r\nconst generateHandlers = (create, config = null) => ({\r\n  get: (!config || config.get) && getPropertyFactory(create),\r\n  set: (!config || config.set) && setPropertyFactory(create),\r\n  apply: (!config || config.apply) && applyFunctionFactory(create),\r\n  construct: (!config || config.construct) && constructFactory(create),\r\n  deleteProperty: (!config || config.deleteProperty) && deletePropertyFactory(create),\r\n});\r\n\r\nexport const createWrapFactory = (proxyConfig) => {\r\n  let wrapInternal;\r\n  const assignInfoAndWrap = (target, info) => {\r\n    setTargetInfo(target, info);\r\n    return wrapInternal(target);\r\n  };\r\n\r\n  const handlers = generateHandlers(assignInfoAndWrap, proxyConfig);\r\n  wrapInternal = withProxy(handlers);\r\n\r\n  return assignInfoAndWrap;\r\n};\r\n\r\nexport const wrap = (target, options = null, proxyConfig = null) => {\r\n  if (!isWrappable(target) || !isEnabled()) {\r\n    return target;\r\n  }\r\n\r\n  const wrapInternal = createWrapFactory(proxyConfig);\r\n  const info = createInfoFromOptions(target, options || undefined);\r\n\r\n  return wrapInternal(target, info);\r\n};\r\n","import { getTargetInfo } from '../../info';\r\nimport {\r\n  getWrapConfigValue,\r\n  WRAP_FUNCTION_ARGUMENTS,\r\n  WRAP_FUNCTION_RETURN_VALUES,\r\n} from '../../config/wrap-config';\r\nimport { getTargetArguments, getTypeCheckedChild } from './apply';\r\n\r\nconst constructFactory = (wrapFn) => (Target, argumentsList) => {\r\n  const info = getTargetInfo(Target);\r\n  const { names, data, checker } = info;\r\n\r\n  if (checker.arguments) {\r\n    checker.arguments(Target, names, argumentsList, data);\r\n  }\r\n\r\n  if (getWrapConfigValue(WRAP_FUNCTION_ARGUMENTS, info)) {\r\n    argumentsList = getTargetArguments(wrapFn, info, argumentsList);\r\n  }\r\n\r\n  let result = new Target(...argumentsList);\r\n\r\n  if (checker.returnValue) {\r\n    checker.returnValue(Target, names, result, data);\r\n  }\r\n\r\n  if (getWrapConfigValue(WRAP_FUNCTION_RETURN_VALUES, info)) {\r\n    result = getTypeCheckedChild(wrapFn, info, 'returnValue', result);\r\n  }\r\n\r\n  return result;\r\n};\r\n\r\nexport default constructFactory;\r\n","import { INFO_KEY, getTargetInfo } from '../../info';\r\nimport { TARGET_KEY } from '../../utils';\r\n\r\nconst deletePropertyFactory = () => (target, property) => {\r\n  if (property === INFO_KEY) {\r\n    return delete target[property];\r\n  } else if (property === TARGET_KEY) {\r\n    return false;\r\n  }\r\n\r\n  const info = getTargetInfo(target);\r\n  const { names, data, checker } = info;\r\n\r\n  checker.deleteProperty(target, names.clone(property), data);\r\n\r\n  return delete target[property];\r\n};\r\n\r\nexport default deletePropertyFactory;\r\n","/* eslint-disable import/prefer-default-export */\r\nimport { isEnabled } from '../config/enabled';\r\nimport { setTargetInfo } from '../info';\r\nimport { isWrappable } from '../utils';\r\nimport { createInfoFromOptions, createWrapFactory } from './wrap';\r\n\r\nconst deepInitializer = (target, info) => {\r\n  const { names, checker, data } = info;\r\n\r\n  Object.keys(target).forEach((name) => {\r\n    const value = target[name];\r\n    const nextNames = names.clone(name);\r\n\r\n    if (checker.getProperty) {\r\n      checker.getProperty(target, nextNames, value, data);\r\n    }\r\n\r\n    if (isWrappable(value)) {\r\n      let childInfo = info.getChild(name);\r\n\r\n      if (!childInfo) {\r\n        childInfo = info.createChildWithNames(nextNames, value);\r\n      }\r\n\r\n      deepInitializer(value, childInfo);\r\n    }\r\n  });\r\n\r\n  setTargetInfo(target, info);\r\n\r\n  return info;\r\n};\r\n\r\nexport const wrapDeep = (target, options, proxyConfig = null) => {\r\n  if (!isWrappable(target) || typeof target !== 'object' || !isEnabled()) {\r\n    return target;\r\n  }\r\n\r\n  const wrapInternal = createWrapFactory(proxyConfig);\r\n  const info = createInfoFromOptions(target, options);\r\n\r\n  deepInitializer(target, info);\r\n\r\n  return wrapInternal(target, info);\r\n};\r\n","import { INFO_KEY } from './target';\n\nexport const getTypeChecker = (target) => {\n  if (target) {\n    const info = target[INFO_KEY];\n\n    return (info && info.checker) || undefined;\n  }\n\n  return undefined;\n};\n\nexport const getTypeCheckerData = (target) => {\n  if (target) {\n    const info = target[INFO_KEY];\n\n    return (info && info.data) || undefined;\n  }\n\n  return undefined;\n};\n"],"names":["Object","defineProperty","exports","value","hasOwn","has","target","property","Boolean","call","prototype","hasOwnProperty","singleConfigFactory","defaultValue","validator","get","set","newValue","getDefaultTypeChecker","setDefaultTypeChecker","isEnabled","setEnabled","getClass","proto","getPrototypeOf","constructor","match","String","def","constructors","Set","addIgnoredClasses","classes","forEach","add","isValueOfIgnoredClass","Map","Date","Error","values","getDefault","getDefaultWrapConfig","getWrapConfig","setWrapConfig","getValue","defaultValues","newValues","assign","key","undefined","mapConfigFactory","keys","getWrapConfigValue","name","AsIs","this","asIs","toString","valueOf","Symbol","toPrimitive","appendPathNameToString","str","string","parseInt","test","PathSequence","[object Object]","lastName","customString","nextName","sequence","append","getChildInfoKey","ChildrenCache","children","cache","store","childInfo","remove","copy","sourceCache","createChildrenCache","INFO_KEY","getTargetInfo","setTargetInfo","info","TargetInfo","checker","data","deep","names","createPathSequence","getChild","storeChildFrom","child","createChildWithNames","init","createChild","clone","mergeConfigs","console","error","isFunction","require$$0","withProxy","handlers","apply","construct","functionHandlers","Proxy","TARGET_KEY","isWrapped","isWrappable","type","isOfWrappableType","wrapConfigKeys","getPropertyFactory","wrapFn","nextNames","getProperty","isIgnoredProperty","getTargetProperty","setPropertyFactory","updateTargetInfo","setProperty","setTargetProperty","setNonTargetProperty","getTypeCheckedChild","getTargetArguments","argumentsList","length","index","createInfoFromOptions","createTargetInfo","generateHandlers","create","config","thisArg","arguments","result","returnValue","applyFunctionFactory","Target","constructFactory","deleteProperty","deletePropertyFactory","createWrapFactory","proxyConfig","wrapInternal","assignInfoAndWrap","deepInitializer","delete","options"],"mappings":"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"}