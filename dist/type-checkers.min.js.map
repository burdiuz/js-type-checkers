{"version":3,"file":"type-checkers.min.js","sources":["../source/defaultTypeChecker.js","../source/errorReporter.js","../source/enabled.js","../source/config.js","../source/proxy.js","../source/typeChecker.js","../source/index.js"],"sourcesContent":["let defaultTypeChecker;\n\nexport const getDefaultTypeChecker = () => defaultTypeChecker;\nexport const setDefaultTypeChecker = (typeChecker) => defaultTypeChecker = typeChecker;\n","const constructErrorString = (action, name, required, actual) =>\n  `TypeChecker error for \"${action}\" on \"${name}\" instead of \"${required}\" received \"${actual}\"`;\n\nexport const ConsoleErrorReporter = (action, name, requiredTypeString, actualTypeString) =>\n  console.error(constructErrorString(action, name, requiredTypeString, actualTypeString));\n\nexport const ConsoleWarnReporter = (action, name, requiredTypeString, actualTypeString) =>\n  console.warn(constructErrorString(action, name, requiredTypeString, actualTypeString));\n\nexport const ThrowErrorReporter = (action, name, requiredTypeString, actualTypeString) => {\n  throw new Error(constructErrorString(action, name, requiredTypeString, actualTypeString));\n};\n\nlet errorReporter = ConsoleErrorReporter;\n\nexport const getErrorReporter = () => errorReporter;\n\nexport const setErrorReporter = (reporter) => errorReporter = reporter;\n","let enabled = true;\n\nexport const isEnabled = () => enabled;\nexport const setEnabled = (value) => enabled = !!value;\n","export const configKey = Symbol('data-checkers::config');\n\nexport const getConfig = (target) => target[configKey];\nexport const setConfig = (target, config) => target[configKey] = config;\n\nexport const getTargetTypeChecker = (target) => target[configKey] && target[configKey].typeChecker;\nexport const getTargetTypeCheckerConfig = (target) => target[configKey] && target[configKey].config;\n","import { getDefaultTypeChecker } from './defaultTypeChecker';\nimport { getErrorReporter } from './errorReporter';\nimport { isEnabled } from './enabled';\nimport { getConfig, setConfig, configKey } from './config';\n\nconst validTypes = {\n  object: true,\n  function: true,\n};\n\nexport const isValidTarget = (target) => target && validTypes[typeof target];\n\nconst getProperty = (target, property) => {\n  // if object or function and deep -- wrap\n  const value = target[property];\n\n  if (property === configKey) {\n    return value;\n  }\n\n  const { deep, names, config, typeChecker } = getConfig(target);\n\n  typeChecker.getProperty && typeChecker.getProperty(target, property, value, config, names);\n\n  if ((deep && isValidTarget(value)) || value instanceof Function) {\n    const { children } = getConfig(target);\n\n    if (!children.hasOwnProperty(property)) {\n      children[property] = create(value, { deep, names: [...names, property] }, typeChecker);\n    }\n\n    return children[property];\n  }\n\n  return value;\n};\n\nconst setProperty = (target, property, value, receiver) => {\n  const { names, config, children, typeChecker } = getConfig(target);\n\n  if (property !== configKey) {\n    delete children[property];\n    typeChecker.setProperty && typeChecker.setProperty(target, property, value, config, names);\n  }\n\n  target[property] = value;\n};\n\nconst callFunction = (target, thisArg, argumentsList) => {\n  const { names, config, typeChecker } = getConfig(target);\n\n  typeChecker.arguments && typeChecker.arguments(target, thisArg, argumentsList, config, names);\n\n  const result = target.apply(thisArg, argumentsList);\n\n  typeChecker.returnValue && typeChecker.returnValue(target, thisArg, result, config, names);\n\n  return result;\n};\n\nconst objectProxy = (target) => new Proxy(\n  target,\n  {\n    get: getProperty,\n    set: setProperty,\n  },\n);\n\nconst functionProxy = (target) => new Proxy(\n  target,\n  {\n    apply: callFunction,\n    construct: callFunction,\n  },\n);\n\nexport const create = (target, { deep = true, names = [] } = {}, typeChecker = getDefaultTypeChecker()) => {\n  if (!isValidTarget(target) || !isEnabled() || getConfig(target)) {\n    return target;\n  }\n\n  setConfig(\n    target,\n    {\n      deep,\n      names,\n      children: {},\n      typeChecker,\n      config: typeChecker.init(target, getErrorReporter()),\n    },\n  );\n\n  if (target instanceof Function) {\n    return functionProxy(target);\n  }\n\n  return objectProxy(target);\n};\n","const buildPath = sequence => sequence\n  .reduce((str, name) => {\n    if (String(parseInt(name, 10)) === name) {\n      str = `${str}[${name}]`;\n    } else if (/^[a-z][\\w$]*$/i.test(name)) {\n      str = str ? `${str}.${name}` : name;\n    } else {\n      str = `${str}[\"${name}\"]`;\n    }\n\n    return str;\n  }, '');\n\nconst checkType = (action, types, name, type, errorReporter, sequence) => {\n  if (!type) {\n    return true;\n  }\n\n  const storedType = types[name];\n\n  if (storedType) {\n    // TODO add possibility to store function in types[name] that can be called to identify if there are type error\n    if (storedType !== type) {\n      errorReporter(action, buildPath([...sequence, name]), types[name], type);\n\n      return false;\n    }\n  } else {\n    types[name] = type;\n  }\n\n  return true;\n};\n\nconst GET_PROPERTY = 'getProperty';\nconst SET_PROPERTY = 'setProperty';\nconst ARGUMENTS = 'arguments';\nconst RETURN_VALUE = 'returnValue';\n\nconst PrimitiveTypeChecker = {\n  collectTypesOnInit: true,\n\n  getTypeString(value) {\n    if (value === undefined) {\n      return '';\n    } else if (value instanceof Array) {\n      return 'array';\n    }\n\n    return typeof value;\n  },\n\n  init(target, errorReporter) {\n    const types = {};\n\n    if (this.collectTypesOnInit) {\n      Object.keys(target)\n        .forEach((key) => {\n          types[key] = this.getTypeString(target[key]);\n        });\n    }\n\n    return {\n      types,\n      errorReporter,\n    };\n  },\n\n  getProperty(target, name, value, { types, errorReporter }, sequence) {\n    return checkType(\n      GET_PROPERTY,\n      types,\n      name,\n      this.getTypeString(value),\n      errorReporter,\n      sequence,\n    );\n  },\n\n  setProperty(target, name, newValue, { types, errorReporter }, sequence) {\n    return checkType(\n      SET_PROPERTY,\n      types,\n      name,\n      this.getTypeString(newValue),\n      errorReporter,\n      sequence,\n    );\n  },\n\n  arguments(target, thisArg, args, { types, errorReporter }, sequence) {\n    const { length } = args;\n    let valid = true;\n\n    for (let index = 0; index < length; index++) {\n      const agrValid = checkType(\n        ARGUMENTS,\n        types,\n        String(index),\n        this.getTypeString(args[index]),\n        errorReporter,\n        sequence,\n      );\n\n      valid = agrValid && valid;\n    }\n\n    return valid;\n  },\n\n  returnValue(target, thisArg, value, { types, errorReporter }, sequence) {\n    return checkType(\n      RETURN_VALUE,\n      types,\n      '',\n      this.getTypeString(value),\n      errorReporter,\n      sequence,\n    );\n  },\n};\n\nexport default PrimitiveTypeChecker;\n","import {\n  getDefaultTypeChecker,\n  setDefaultTypeChecker,\n} from './defaultTypeChecker';\nimport {\n  ConsoleErrorReporter,\n  ConsoleWarnReporter,\n  getErrorReporter,\n  setErrorReporter,\n  ThrowErrorReporter,\n} from './errorReporter';\nimport {\n  isEnabled,\n  setEnabled,\n} from './enabled';\nimport {\n  getTargetTypeChecker,\n  getTargetTypeCheckerConfig,\n} from './config';\nimport {\n  create,\n  isValidTarget,\n} from './proxy';\nimport PrimitiveTypeChecker from './typeChecker';\n\nexport {\n  getDefaultTypeChecker,\n  setDefaultTypeChecker,\n  ConsoleErrorReporter,\n  ConsoleWarnReporter,\n  getErrorReporter,\n  setErrorReporter,\n  ThrowErrorReporter,\n  isEnabled,\n  setEnabled,\n  getTargetTypeChecker,\n  getTargetTypeCheckerConfig,\n  create,\n  isValidTarget,\n};\n\nsetDefaultTypeChecker(PrimitiveTypeChecker);\n\nexport default create;\n"],"names":["defaultTypeChecker","getDefaultTypeChecker","setDefaultTypeChecker","typeChecker","constructErrorString","action","name","required","actual","ConsoleErrorReporter","requiredTypeString","actualTypeString","console","error","errorReporter","getErrorReporter","enabled","isEnabled","configKey","Symbol","getConfig","target","validTypes","isValidTarget","getProperty","property","value","deep","names","config","Function","children","hasOwnProperty","create","setProperty","receiver","callFunction","thisArg","argumentsList","arguments","result","apply","returnValue","init","Proxy","checkType","types","type","sequence","storedType","reduce","str","String","parseInt","test","undefined","Array","this","collectTypesOnInit","keys","forEach","key","getTypeString","newValue","args","length","valid","index","warn","reporter","Error"],"mappings":"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"}