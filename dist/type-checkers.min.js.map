{"version":3,"file":"type-checkers.min.js","sources":["../source/checkers/utils.js","../source/target/info.js","../source/checkers/primitive.js","../source/checkers/index.js","../source/reporters/utils.js","../source/reporters/console.js","../source/reporters/index.js","../source/enabled.js","../source/proxy/config.js","../source/target/proxy.js","../source/utils.js","../source/proxy/create.js","../source/proxy/getProperty.js","../source/proxy/setProperty.js","../source/proxy/callFunction.js","../source/proxy/createDeep.js","../source/reporters/error.js","../source/target/objectMerge.js"],"sourcesContent":["\nexport const GET_PROPERTY = 'GetProperty';\nexport const SET_PROPERTY = 'SetProperty';\nexport const ARGUMENTS = 'Arguments';\nexport const RETURN_VALUE = 'ReturnValue';\nexport const MERGE = 'Merge';\n\nexport const buildPath = sequence => sequence\n  .reduce((str, name) => {\n    if (String(parseInt(name, 10)) === name) {\n      str = `${str}[${name}]`;\n    } else if (/^[a-z][\\w$]*$/i.test(name)) {\n      str = str ? `${str}.${name}` : name;\n    } else {\n      str = `${str}[\"${name}\"]`;\n    }\n\n    return str;\n  }, '');\n","export const INFO_KEY = Symbol('type-checkers::info');\n\nexport const createTargetInfo = (\n  checker,\n  config,\n  deep = true,\n  names = [],\n  children = createChildrenCache(),\n) => ({\n  checker,\n  config,\n  deep,\n  names,\n  children,\n});\n\nexport const getTargetInfo = (target) => {\n  return target ? target[INFO_KEY] : undefined;\n};\n\nexport const setTargetInfo = (target, info) => {\n  if (target && info) {\n    target[INFO_KEY] = info;\n  }\n};\n\nexport const hasTargetInfo = (target) => !!getTargetInfo(target);\n\nexport const getTargetTypeChecker = (target) => {\n  return target && target[INFO_KEY] ? target[INFO_KEY].checker : undefined;\n};\n\nexport const getTargetTypeCheckerConfig = (target) =>\n  (target && target[INFO_KEY] ? target[INFO_KEY].config : undefined);\n\nexport const createChildrenCache = (children = {}) => ({ ...children });\n\nexport const mergeChildrenCache = (targetCache, sourceCache) => {\n  for (const name in sourceCache) {\n    if (targetCache.hasOwnProperty(name)) {\n      targetCache[name] = mergeTargetInfo(targetCache[name], sourceCache[name]);\n    } else {\n      targetCache[name] = sourceCache[name];\n    }\n  }\n\n  return targetCache;\n};\n\nexport const storeChildInfo = (cache, name, childInfo) => {\n  delete cache[name];\n\n  if (childInfo) {\n    cache[name] = childInfo;\n  }\n};\n\nexport const storeChildInfoFrom = (cache, name, child) => {\n  storeChildInfo(cache, name, getTargetInfo(child));\n};\n\nexport const getChildInfo = (cache, name) => cache[name];\n\nexport const hasChildInfo = (cache, name) => !!cache[name];\n\nexport const removeChildInfo = (cache, name) => delete cache[name];\n\nexport const mergeTargetInfo = (targetInfo, sourceInfo) => {\n  const { deep, checker, children, config, names } = targetInfo;\n\n  if (checker === sourceInfo.checker) {\n    targetInfo.deep = deep || sourceInfo.deep;\n    targetInfo.children = mergeChildrenCache(children, sourceInfo.children);\n    targetInfo.config = checker.mergeConfigs(config, sourceInfo.config, names);\n  } else {\n    console.error('TypeChecked objects can be merged only if using exactly same instance of type checker.');\n  }\n\n  return targetInfo;\n};\n","import {\n  ARGUMENTS,\n  GET_PROPERTY,\n  RETURN_VALUE,\n  SET_PROPERTY,\n  MERGE,\n  buildPath,\n} from './utils';\n\nimport { getTargetTypeCheckerConfig } from '../target/info';\n\nconst checkPrimitiveType = (action, types, name, type, errorReporter, sequence) => {\n  if (!type) {\n    return true;\n  }\n\n  const storedType = types[name];\n\n  if (storedType) {\n    if (storedType !== type) {\n      errorReporter(action, buildPath([...sequence, name]), storedType, type);\n\n      return false;\n    }\n  } else {\n    types[name] = type;\n  }\n\n  return true;\n};\n\nconst PrimitiveTypeChecker = {\n  collectTypesOnInit: true,\n\n  init(target, errorReporter, cachedTypes = null) {\n    let types = {};\n\n    if (cachedTypes) {\n      types = cachedTypes;\n    } else if (this.collectTypesOnInit) {\n      Object.keys(target)\n        .forEach((key) => {\n          types[key] = this.getTypeString(target[key]);\n        });\n    }\n\n    return {\n      types,\n      errorReporter,\n    };\n  },\n\n  getTypeString(value) {\n    if (value === undefined) {\n      return '';\n    } else if (value instanceof Array) {\n      return 'array';\n    }\n\n    return typeof value;\n  },\n\n  mergeConfigs({ types, errorReporter }, source, names = []) {\n    const sourceTypes = source.types;\n\n    for (const name in sourceTypes) {\n      if (sourceTypes.hasOwnProperty(name)) {\n        const sourceType = sourceTypes[name];\n        const targetType = types[name];\n\n        if (sourceType && targetType && targetType !== sourceType) {\n          errorReporter(MERGE, buildPath([...names, name]), targetType, sourceType);\n        } else {\n          types[name] = sourceType;\n        }\n      }\n    }\n  },\n\n  replacePropertyTypeCheck(target, name, typeCheckFn) {\n    const { types } = getTargetTypeCheckerConfig(target);\n    delete types[name];\n\n    if (typeCheckFn) {\n      types[name] = typeCheckFn;\n    }\n  },\n\n  replaceArgumentsTypeCheck(target, name, argumentsTypeCheckFn) {\n    const { types } = getTargetTypeCheckerConfig(target);\n    delete types[ARGUMENTS];\n\n    if (argumentsTypeCheckFn) {\n      types[name] = argumentsTypeCheckFn;\n    }\n  },\n\n  replaceReturnValueTypeCheck(target, name, returnValueTypeCheckFn) {\n    const { types } = getTargetTypeCheckerConfig(target);\n    delete types[RETURN_VALUE];\n\n    if (returnValueTypeCheckFn) {\n      types[RETURN_VALUE] = returnValueTypeCheckFn;\n    }\n  },\n\n  getProperty(target, name, value, config, sequence) {\n    const { types, errorReporter } = config;\n    const typeFn = types[name];\n\n    if (typeFn instanceof Function) {\n      return typeFn(GET_PROPERTY, target, name, value, config, sequence);\n    }\n\n    const type = this.getTypeString(value);\n\n    return checkPrimitiveType(GET_PROPERTY, types, name, type, errorReporter, sequence);\n  },\n\n  setProperty(target, name, newValue, config, sequence) {\n    const { types, errorReporter } = config;\n    const typeFn = types[name];\n\n    if (typeFn instanceof Function) {\n      return typeFn(SET_PROPERTY, target, name, newValue, config, sequence);\n    }\n\n    const type = this.getTypeString(newValue);\n\n    return checkPrimitiveType(\n      SET_PROPERTY,\n      types,\n      name,\n      type,\n      errorReporter,\n      sequence,\n    );\n  },\n\n  arguments(target, thisArg, args, config, sequence) {\n    const { types, errorReporter } = config;\n    const typeFn = types[ARGUMENTS];\n\n    if (typeFn instanceof Function) {\n      return typeFn(ARGUMENTS, target, args, config, sequence);\n    }\n\n    const { length } = args;\n    let valid = true;\n\n    for (let index = 0; index < length; index++) {\n      const type = this.getTypeString(args[index]);\n      const agrValid = checkPrimitiveType(\n        ARGUMENTS,\n        types,\n        String(index),\n        type,\n        errorReporter,\n        sequence,\n      );\n\n      valid = agrValid && valid;\n    }\n\n    return valid;\n  },\n\n  returnValue(target, thisArg, value, config, sequence) {\n    const { types, errorReporter } = config;\n    const typeFn = types[RETURN_VALUE];\n\n    if (typeFn instanceof Function) {\n      return typeFn(ARGUMENTS, target, value, config, sequence);\n    }\n\n    const type = this.getTypeString(value);\n\n    return checkPrimitiveType(\n      RETURN_VALUE,\n      types,\n      RETURN_VALUE,\n      type,\n      errorReporter,\n      sequence,\n    );\n  },\n};\n\nexport default PrimitiveTypeChecker;\n","import PrimitiveTypeChecker from './primitive';\n\nlet defaultTypeChecker = PrimitiveTypeChecker;\n\nexport const getDefaultTypeChecker = () => defaultTypeChecker;\nexport const setDefaultTypeChecker = (typeChecker) => {\n  defaultTypeChecker = typeChecker;\n};\n","export const constructErrorString = (action, name, required, actual) =>\n  `${action}Error on \"${name}\" instead of \"${required}\" received \"${actual}\"`;\n","import { constructErrorString } from './utils';\n\nexport const ConsoleErrorReporter = (action, name, requiredTypeString, actualTypeString) =>\n  console.error(constructErrorString(action, name, requiredTypeString, actualTypeString));\n\nexport const ConsoleWarnReporter = (action, name, requiredTypeString, actualTypeString) =>\n  console.warn(constructErrorString(action, name, requiredTypeString, actualTypeString));\n","import { ConsoleErrorReporter } from './console';\n\nlet errorReporter = ConsoleErrorReporter;\n\nexport const getErrorReporter = () => errorReporter;\n\nexport const setErrorReporter = (reporter) => errorReporter = reporter;\n","let enabled = true;\n\nexport const isEnabled = () => enabled;\nexport const setEnabled = (value = true) => enabled = !!value;\n","export const config = {\n  wrapFunctionReturnValues: true,\n  wrapFunctionArguments: false,\n  wrapSetPropertyValues: true,\n};\n\nexport const setProxyConfig = (newConfig) => Object.assign(config, newConfig);\n\nexport const getProxyConfig = () => ({ ...config });\n","export const TARGET_KEY = Symbol('type-checkers::target');\n\nexport const getOriginalTarget = (target) => {\n  return target[TARGET_KEY] || target;\n};","import { TARGET_KEY } from './target/proxy';\n\nconst validTypes = {\n  object: true,\n  function: true,\n};\n\nexport const isValidTarget = (target) => target && validTypes[typeof target];\nexport const isTypeChecked = (target) => Boolean(target && target[TARGET_KEY]);","import { getDefaultTypeChecker } from '../checkers';\nimport { getErrorReporter } from '../reporters';\nimport { isEnabled } from '../enabled';\nimport {\n  createTargetInfo,\n  setTargetInfo,\n  createChildrenCache,\n} from '../target/info';\nimport { isValidTarget, isTypeChecked } from '../utils';\nimport getPropertyInit from './getProperty';\nimport setPropertyInit from './setProperty';\nimport callFunctionInit from './callFunction';\n\nlet getProperty;\nlet setProperty;\nlet callFunction;\n\nconst objectProxy = (target) => new Proxy(\n  target,\n  {\n    get: getProperty,\n    set: setProperty,\n  },\n);\n\nconst functionProxy = (target) => new Proxy(\n  target,\n  {\n    apply: callFunction,\n    construct: callFunction,\n  },\n);\n\nexport const wrapWithProxy = (target) => {\n  if (target instanceof Function) {\n    return functionProxy(target);\n  }\n\n  return objectProxy(target);\n};\n\nexport const createInfoFromOptions = (target, {\n  deep = true,\n  names = [],\n  config = null,\n  children = null,\n  checker = getDefaultTypeChecker(),\n  info = null, // exclusive option, if set other options being ignored\n} = {}) => info || createTargetInfo(\n  checker,\n  checker.init(target, getErrorReporter(), config),\n  deep,\n  names,\n  createChildrenCache(children),\n);\n\nconst create = (target, options) => {\n  if (!isValidTarget(target) || !isEnabled() || isTypeChecked(target)) {\n    return target;\n  }\n\n  setTargetInfo(\n    target,\n    createInfoFromOptions(target, options),\n  );\n\n  return wrapWithProxy(target);\n};\n\ngetProperty = getPropertyInit(create);\nsetProperty = setPropertyInit(create);\ncallFunction = callFunctionInit(create);\n\nexport default create;\n","import {\n  INFO_KEY,\n  getTargetInfo,\n  getChildInfo,\n  storeChildInfoFrom,\n} from '../target/info';\nimport { TARGET_KEY } from '../target/proxy';\nimport { isValidTarget, isTypeChecked } from '../utils';\n\nconst getTargetProperty = (createFn, target, property, value) => {\n  const info = getTargetInfo(target);\n  const { deep, children, names, checker } = info;\n\n  if (deep || value instanceof Function) {\n    const childInfo = getChildInfo(children, property);\n\n    if (childInfo) {\n      value = createFn(value, { info: childInfo });\n    } else {\n      value = createFn(value, { deep, names: [...names, property], checker });\n      storeChildInfoFrom(children, property, value);\n    }\n  }\n\n  return value;\n};\n\nconst getProperty = (createFn) => (target, property) => {\n  const value = target[property];\n\n  if (property === INFO_KEY) {\n    return value;\n    /*\n    target[TARGET_KEY] is a virtual property accessing which indicates\n    if object is wrapped with type checked proxy or not.\n    */\n  } else if (property === TARGET_KEY) {\n    return target;\n  }\n\n  const info = getTargetInfo(target);\n  const { names, config, checker } = info;\n\n  if (checker.getProperty) {\n    checker.getProperty(target, property, value, config, names);\n  }\n\n  if (!isValidTarget(value) || isTypeChecked(value)) {\n    return value;\n  }\n\n  return getTargetProperty(createFn, target, property, value);\n};\n\nexport default getProperty;\n","import {\n  INFO_KEY,\n  getTargetInfo,\n  getChildInfo,\n  storeChildInfoFrom,\n  mergeTargetInfo,\n} from '../target/info';\nimport { TARGET_KEY } from '../target/proxy';\nimport { config as proxyConfig } from './config';\nimport { isValidTarget, isTypeChecked } from '../utils';\n\nconst setNonTargetProperty = (target, property, value) => {\n  if (property === INFO_KEY) {\n    let info = getTargetInfo(target);\n    if (info && value && info !== value) {\n      info = mergeTargetInfo(info, value);\n    } else {\n      info = value;\n    }\n\n    target[property] = info;\n    return true;\n  } else if (!isValidTarget(value)) {\n    target[property] = value;\n    return true;\n  }\n\n  return false;\n};\n\nconst setTargetProperty = (createFn, target, property, value) => {\n  if (proxyConfig.wrapSetPropertyValues) {\n    const { deep, names, checker, children } = getTargetInfo(target);\n\n    if (!isTypeChecked(value)) {\n      const childInfo = getChildInfo(children, property);\n\n      if (childInfo) {\n        value = createFn(value, { info: childInfo });\n      } else {\n        value = createFn(value, { deep, names: [...names, property], checker });\n      }\n    }\n\n    storeChildInfoFrom(children, property, value);\n  }\n\n  target[property] = value;\n  return true;\n};\n\nconst setProperty = (createFn) => (target, property, value) => {\n  if (property === TARGET_KEY) {\n    throw new Error(`\"${TARGET_KEY}\" is a virtual property and cannot be set`);\n  }\n\n  const { names, config, checker } = getTargetInfo(target);\n\n  if (checker.setProperty) {\n    checker.setProperty(target, property, value, config, names);\n  }\n\n  return setNonTargetProperty(target, property, value)\n    || setTargetProperty(createFn, target, property, value);\n};\n\nexport default setProperty;\n","import {\n  getTargetInfo,\n  getChildInfo,\n  storeChildInfoFrom,\n} from '../target/info';\nimport { config as proxyConfig } from './config';\nimport { isTypeChecked } from '../utils';\nimport { RETURN_VALUE } from '../checkers/utils';\n\nconst getTargetArguments = (createFn, target, argumentsList) => {\n  if (proxyConfig.wrapFunctionArguments) {\n    const { deep, names, checker } = getTargetInfo(target);\n    const { length } = argumentsList;\n    // FIXME cache arguments info objects as children\n    for (let index = 0; index < length; index++) {\n      argumentsList[index] = createFn(\n        argumentsList[index],\n        {\n          deep,\n          names: [...names, index],\n          checker,\n        },\n      );\n    }\n  }\n\n  return argumentsList;\n};\nconst getTargetReturnValue = (createFn, target, returnValue) => {\n  if (proxyConfig.wrapFunctionReturnValues) {\n    const { deep, names, checker, children } = getTargetInfo(target);\n\n    if (!isTypeChecked(returnValue)) {\n      const childInfo = getChildInfo(children, RETURN_VALUE);\n\n      if (childInfo) {\n        returnValue = createFn(returnValue, { info: childInfo });\n      } else {\n        returnValue = createFn(returnValue, { deep, names: [...names], checker });\n      }\n    }\n\n    storeChildInfoFrom(children, RETURN_VALUE, returnValue);\n  }\n\n  return returnValue;\n};\n\nconst callFunction = (createFn) => (target, thisArg, argumentsList) => {\n  const info = getTargetInfo(target);\n  const { names, config, checker } = info;\n\n  if (checker.arguments) {\n    checker.arguments(target, thisArg, argumentsList, config, names);\n  }\n\n  argumentsList = getTargetArguments(createFn, target, argumentsList);\n\n  const result = target.apply(thisArg, argumentsList);\n\n  if (checker.returnValue) {\n    checker.returnValue(target, thisArg, result, config, names);\n  }\n\n  return getTargetReturnValue(createFn, target, result);\n};\n\nexport default callFunction;\n","import { isEnabled } from '../enabled';\nimport {\n  setTargetInfo,\n  storeChildInfo,\n  getChildInfo,\n} from '../target/info';\nimport { isTypeChecked } from '../utils';\nimport { wrapWithProxy, createInfoFromOptions } from './create';\n\nconst deepInitializer = (target, options) => {\n  const info = createInfoFromOptions(target, options);\n  const { deep, names, checker, config, children } = info;\n\n  Object.keys(target)\n    .forEach((name) => {\n      const value = target[name];\n\n      checker.getProperty(target, name, value, config, names);\n\n      // skip functions/methods since we get info about them only when being executed\n      if (typeof value === 'object') {\n        let childInfo = getChildInfo(children, name);\n\n        if (childInfo) {\n          deepInitializer(value, { info: childInfo });\n        } else {\n          childInfo = deepInitializer(value, { deep, names: [...names, name], checker });\n          storeChildInfo(children, name, childInfo);\n        }\n      }\n    });\n\n  setTargetInfo(target, info);\n\n  return info;\n};\n\nconst createDeep = (target, options) => {\n  if (!target || typeof target !== 'object' || !isEnabled() || isTypeChecked(target)) {\n    return target;\n  }\n\n  deepInitializer(target, options);\n\n  return wrapWithProxy(target);\n};\n\nexport default createDeep;\n","import { constructErrorString } from './utils';\n\nexport const ThrowErrorReporter = (action, name, requiredTypeString, actualTypeString) => {\n  throw new Error(constructErrorString(action, name, requiredTypeString, actualTypeString));\n};\n","import {\n  getTargetInfo,\n  hasTargetInfo,\n} from './info';\n\nimport { create } from '../proxy';\n\nimport { isEnabled } from '../enabled';\n\nconst objectMerge = (options, ...sources) => {\n  let target = {};\n\n  if (isEnabled()) {\n    if (!options) {\n      options = {\n        info: getTargetInfo(sources.find((item) => hasTargetInfo(item))),\n        deep: false,\n      };\n    }\n\n    target = create(target, options);\n  }\n\n  return Object.assign(target, ...sources);\n};\n\nexport default objectMerge;\n"],"names":["GET_PROPERTY","SET_PROPERTY","ARGUMENTS","RETURN_VALUE","buildPath","sequence","reduce","str","name","String","parseInt","test","Symbol","getTargetInfo","target","INFO_KEY","undefined","setTargetInfo","info","hasTargetInfo","getTargetTypeCheckerConfig","config","createChildrenCache","children","storeChildInfo","cache","childInfo","storeChildInfoFrom","child","getChildInfo","mergeTargetInfo","targetInfo","sourceInfo","deep","checker","names","targetCache","sourceCache","hasOwnProperty","mergeChildrenCache","mergeConfigs","error","checkPrimitiveType","action","types","type","errorReporter","storedType","PrimitiveTypeChecker","cachedTypes","this","collectTypesOnInit","keys","forEach","key","getTypeString","value","Array","source","sourceTypes","sourceType","targetType","typeCheckFn","argumentsTypeCheckFn","returnValueTypeCheckFn","typeFn","Function","newValue","thisArg","args","length","valid","index","defaultTypeChecker","getDefaultTypeChecker","constructErrorString","required","actual","actualTypeString","ConsoleErrorReporter","getErrorReporter","enabled","isEnabled","TARGET_KEY","validTypes","isValidTarget","isTypeChecked","Boolean","getProperty","setProperty","callFunction","wrapWithProxy","Proxy","createInfoFromOptions","createTargetInfo","init","create","options","createFn","property","getTargetProperty","Error","setNonTargetProperty","proxyConfig","wrapSetPropertyValues","setTargetProperty","argumentsList","arguments","wrapFunctionArguments","getTargetArguments","result","apply","returnValue","wrapFunctionReturnValues","getTargetReturnValue","deepInitializer","typeChecker","requiredTypeString","console","warn","reporter","sources","find","item","Object","assign","newConfig"],"mappings":"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"}