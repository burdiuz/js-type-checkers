!function(e,r){"object"==typeof exports&&"undefined"!=typeof module?r(exports):"function"==typeof define&&define.amd?define(["exports"],r):r(e.TypeCheckers={})}(this,function(e){"use strict";const r="(GetProperty)",t="(SetProperty)",n="(Index)",o="(Arguments)",c="(ReturnValue)";function s(e){if(!(this instanceof s))return new s(e);this.value=e}function i(){return this.value}s.prototype.toString=i,s.prototype.valueOf=i,s.prototype[Symbol.toPrimitive]=i;const p=e=>e.reduce((e,r)=>e=r instanceof s?`${e}${r}`:String(parseInt(r,10))===r?`${e}[${r}]`:/^[a-z][\w$]*$/i.test(r)?e?`${e}.${r}`:r:`${e}["${r}"]`,""),a=Symbol("type-checkers::info"),u=e=>e?e[a]:void 0,f=(e,r)=>{e&&r&&(e[a]=r)},y=e=>!!u(e),l=e=>e&&e[a]?e[a].config:void 0,d=(e={})=>Object.assign({},e),g=(e,r,t)=>{delete e[r],t&&(e[r]=t)},h=(e,r,t)=>{g(e,r,u(t))},m=(e,r)=>e[r],k=(e,r)=>{const{deep:t,checker:n,children:o,config:c,names:s}=e;return n===r.checker?(e.deep=t||r.deep,e.children=((e,r)=>{for(const t in r)e.hasOwnProperty(t)?e[t]=k(e[t],r[t]):e[t]=r[t];return e})(o,r.children),e.config=n.mergeConfigs(c,r.config,s)):console.error("TypeChecked objects can be merged only if using exactly same instance of type checker."),e},P=(e,r,t,n,o,c)=>{if(!n)return!0;const s=r[t];if(s){if(s!==n)return o(e,p([...c,t]),s,n),!1}else r[t]=n;return!0},T=[Array],b=e=>e&&T.indexOf(e.constructor)>=0,C=e=>void 0===e?"":e instanceof Array?"array":typeof e,x=(e,r)=>{const t=l(e);t&&(t.types[n]=r)},w={collectTypesOnInit:!0,areArrayElementsOfSameType:!0,init(e,r,t=null){let n={};return t?n=t:this.collectTypesOnInit&&Object.keys(e).forEach(r=>{n[r]=C(e[r])}),{types:n,errorReporter:r}},getProperty(e,r,t,n,o){return this.areArrayElementsOfSameType&&b(e)?this.getIndexProperty(e,r,t,n,o):this.getNamedProperty(e,r,t,n,o)},getIndexProperty(e,t,o,c,i){const{types:p,errorReporter:a}=c,u=p[t];if(u instanceof Function)return u(r,e,t,o,c,i);const f=C(o);return P(r,p,s(n),f,a,i)},getNamedProperty(e,t,n,o,c){const{types:s,errorReporter:i}=o,p=s[t];if(p instanceof Function)return p(r,e,t,n,o,c);const a=C(n);return P(r,s,t,a,i,c)},setProperty(e,r,t,n,o){return this.areArrayElementsOfSameType&&b(e)?this.setIndexProperty(e,r,t,n,o):this.setNamedProperty(e,r,t,n,o)},setIndexProperty(e,r,o,c,i){const{types:p,errorReporter:a}=c,u=p[r];if(u instanceof Function)return u(t,e,r,o,c,i);const f=C(o);return P(t,p,s(n),f,a,i)},setNamedProperty(e,r,n,o,c){const{types:s,errorReporter:i}=o,p=s[r];if(p instanceof Function)return p(t,e,r,n,o,c);const a=C(n);return P(t,s,r,a,i,c)},arguments(e,r,t,n,c){const{types:s,errorReporter:i}=n,p=s[o];if(p instanceof Function)return p(o,e,t,n,c);const{length:a}=t;let u=!0;for(let e=0;e<a;e++){const r=C(t[e]);u=P(o,s,String(e),r,i,c)&&u}return u},returnValue(e,r,t,n,i){const{types:p,errorReporter:a}=n,u=p[c];if(u instanceof Function)return u(o,e,t,n,i);const f=C(t);return P(c,p,s(c),f,a,i)},isIndexAccessTarget:b,getTypeString:C,mergeConfigs:({types:e,errorReporter:r},t,n=[])=>{const o=t.types;for(const t in o)if(o.hasOwnProperty(t)){const c=o[t],s=e[t];c&&s&&s!==c?r("(Merge)",p([...n,t]),s,c):e[t]=c}},replacePropertyTypeCheck:(e,r,t)=>{const{types:n}=l(e);delete n[r],t&&(n[r]=t)},replaceArgumentsTypeCheck:(e,r,t)=>{const{types:n}=l(e);delete n[o],t&&(n[r]=t)},replaceReturnValueTypeCheck:(e,r,t)=>{const{types:n}=l(e);delete n[c],t&&(n[c]=t)},registerIndexBasedClass:e=>{T.push(e)},setIndexValueType:x,setIndexValueTypeBy:(e,r)=>{x(e,C(r))},replaceIndexedTypeCheck:(e,r)=>{const{types:t}=l(e);delete t[n],r&&(t[n]=r)}};let I=w;const R=()=>I,O=(e,r,t,n)=>`${e}Error on "${r}" instead of "${t}" received "${n}"`,v=(e,r,t,n)=>console.error(O(e,r,t,n));let $=v;const E=()=>$;let j=!0;const S=()=>j,F={wrapFunctionReturnValues:!0,wrapFunctionArguments:!1,wrapSetPropertyValues:!0},V=Symbol("type-checkers::target"),A={object:!0,function:!0},N=e=>e&&A[typeof e],B=e=>Boolean(e&&e[V]);let D,M,_;const z=e=>e instanceof Function?new Proxy(e,{apply:_,construct:_}):new Proxy(e,{get:D,set:M});const G=(e,{deep:r=!0,names:t=[],config:n=null,children:o=null,checker:c=R(),info:s=null}={})=>s||((e,r,t=!0,n=[],o=d())=>({checker:e,config:r,deep:t,names:n,children:o}))(c,c.init(e,E(),n),r,t,d(o)),W=(e,r)=>N(e)&&S()&&!B(e)?(f(e,G(e,r)),z(e)):e;q=W,D=((e,r)=>{const t=e[r];if(r===a)return t;if(r===V)return e;const n=u(e),{names:o,config:c,checker:s}=n;return s.getProperty&&s.getProperty(e,r,t,c,o),!N(t)||B(t)?t:((e,r,t,n)=>{const o=u(r),{deep:c,children:s,names:i,checker:p}=o;if(c||n instanceof Function){const r=m(s,t);r?n=e(n,{info:r}):(n=e(n,{deep:c,names:[...i,t],checker:p}),h(s,t,n))}return n})(q,e,r,t)});var q;H=W,M=((e,r,t)=>{if(r===V)throw new Error(`"${V}" is a virtual property and cannot be set`);const{names:n,config:o,checker:c}=u(e);return c.setProperty&&c.setProperty(e,r,t,o,n),((e,r,t)=>{if(r===a){let n=u(e);return n=n&&t&&n!==t?k(n,t):t,e[r]=n,!0}return!N(t)&&(e[r]=t,!0)})(e,r,t)||((e,r,t,n)=>{if(F.wrapSetPropertyValues){const{deep:o,names:c,checker:s,children:i}=u(r);if(!B(n)){const r=m(i,t);n=e(n,r?{info:r}:{deep:o,names:[...c,t],checker:s})}h(i,t,n)}return r[t]=n,!0})(H,e,r,t)});var H;J=W,_=((e,r,t)=>{const n=u(e),{names:o,config:s,checker:i}=n;i.arguments&&i.arguments(e,r,t,s,o),t=((e,r,t)=>{if(F.wrapFunctionArguments){const{deep:n,names:o,checker:c}=u(r),{length:s}=t;for(let r=0;r<s;r++)t[r]=e(t[r],{deep:n,names:[...o,r],checker:c})}return t})(J,e,t);const p=e.apply(r,t);return i.returnValue&&i.returnValue(e,r,p,s,o),((e,r,t)=>{if(F.wrapFunctionReturnValues){const{deep:n,names:o,checker:s,children:i}=u(r);if(!B(t)){const r=m(i,c);t=e(t,r?{info:r}:{deep:n,names:[...o],checker:s})}h(i,c,t)}return t})(J,e,p)});var J;const K=(e,r)=>{const t=G(e,r),{deep:n,names:o,checker:c,config:s,children:i}=t;return Object.keys(e).forEach(r=>{const t=e[r];if(c.getProperty(e,r,t,s,o),"object"==typeof t){let e=m(i,r);e?K(t,{info:e}):(e=K(t,{deep:n,names:[...o,r],checker:c}),g(i,r,e))}}),f(e,t),t};e.PrimitiveTypeChecker=w,e.getDefaultTypeChecker=R,e.setDefaultTypeChecker=(e=>{I=e}),e.ConsoleErrorReporter=v,e.ConsoleWarnReporter=((e,r,t,n)=>console.warn(O(e,r,t,n))),e.ThrowErrorReporter=((e,r,t,n)=>{throw new Error(O(e,r,t,n))}),e.getErrorReporter=E,e.setErrorReporter=(e=>$=e),e.isEnabled=S,e.setEnabled=((e=!0)=>j=!!e),e.getTargetInfo=u,e.hasTargetInfo=y,e.setTargetInfo=f,e.getTargetTypeChecker=(e=>e&&e[a]?e[a].checker:void 0),e.getTargetTypeCheckerConfig=l,e.mergeTargetInfo=k,e.objectMerge=((e,...r)=>{let t={};return S()&&(e||(e={info:u(r.find(e=>y(e))),deep:!1}),t=W(t,e)),Object.assign(t,...r)}),e.getProxyConfig=(()=>Object.assign({},F)),e.setProxyConfig=(e=>Object.assign(F,e)),e.create=W,e.createDeep=((e,r)=>e&&"object"==typeof e&&S()&&!B(e)?(K(e,r),z(e)):e),e.isTypeChecked=B,e.isValidTarget=N,e.default=W,Object.defineProperty(e,"__esModule",{value:!0})});
//# sourceMappingURL=type-checkers.min.js.map
