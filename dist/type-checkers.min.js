!function(e,t){"object"==typeof exports&&"undefined"!=typeof module?t(exports):"function"==typeof define&&define.amd?define(["exports"],t):t(e.TypeCheckers={})}(this,function(e){"use strict";function t(e){return e&&e.__esModule&&Object.prototype.hasOwnProperty.call(e,"default")?e.default:e}function r(e,t){return e(t={exports:{}},t.exports),t.exports}var n=r(function(e,t){Object.defineProperty(t,"__esModule",{value:!0});const r=(e=>(t,r)=>Boolean(t&&e.call(t,r)))(Object.prototype.hasOwnProperty);t.hasOwn=r,t.default=r}),s=t(n);n.hasOwn;const a=(e=null,t)=>{let r=e;return{get:()=>r,set:(n=e)=>{r=t?t(n):n}}},{get:o,set:c}=a(),{get:u,set:i}=a(!0,e=>!!e);var l=r(function(e,t){Object.defineProperty(t,"__esModule",{value:!0});const r=e=>{if(null==e)return;const t=Object.getPrototypeOf(e);return"object"==typeof t?t.constructor:t};t.getClassName=(e=>{if(!e)return"";const t=String(r(e)).match(/^(?:[^\(\{\s]*)(?:class|function)\s+([\w\d_$]+)(?:\s*\(|\s*\{|\s+extends)/);return t?t[1]:""}),t.getParentClass=(e=>{const t=r(e);return t&&Object.getPrototypeOf(t)}),t.getClass=r,t.default=r});t(l);l.getClassName,l.getParentClass;var h=l.getClass;const p=new Set,d=(...e)=>{e.forEach(e=>{e&&!p.has(e)&&p.add(e)})},f=e=>p.has(h(e));d(Map,Set,Date,Error);const{values:g,getDefault:y,get:m,set:v,getValue:C}=((e={},t)=>{const r=()=>({...e}),n=r();return{values:n,getDefault:r,set:e=>Object.assign(n,t?t(e):e),get:()=>({...n}),getValue:e=>s(n,e)?n[e]:void 0}})({wrapFunctionReturnValues:!0,wrapFunctionArguments:!1,wrapSetPropertyValues:!1,ignorePrototypeMethods:!1},e=>Object.keys(e).forEach(t=>{e[t]=!!e[t]})),P=(e,t)=>{let r=t[e];return t&&(r=t[e]),void 0===r?C(e):r};var w=r(function(e,t){function r(e){if(!(this instanceof r))return new r(e);this.value=e}function n(){return this.value}Object.defineProperty(t,"__esModule",{value:!0}),r.prototype.toString=n,r.prototype.valueOf=n,r.prototype[Symbol.toPrimitive]=n;const s=(e,t)=>{const n=String(e)||"";return t instanceof r?`${n}${t}`:String(parseInt(t,10))===t?`${n}[${t}]`:/^[a-z_$][\w\d$_]*$/i.test(t)?n?`${n}.${t}`:t:`${n}["${t}"]`};class a{constructor(e){this.value=e?String(e):"",this.lastName=void 0}append(e){this.value=s(this.value,e),this.lastName=e}appendCustomValue(e){this.value=s(this.value,r(e)),this.lastName=e}clone(e){const t=new a(this.value);return void 0===e?t.lastName=this.lastName:t.append(e),t}getLastName(){return this.lastName}toString(){return this.value}valueOf(){return this.value}}t.createPathSequence=(e=>new a(e)),t.default=a});t(w);var b=w.createPathSequence;const k=e=>`@${e}`;class O{constructor(e){this.cache=e?{...e.cache}:{}}store(e,t){const r=k(e);t?this.cache[r]=t:delete this.cache[r]}get(e){return this.cache[k(e)]}has(e){return!!this.cache[k(e)]}remove(e,t){return delete this.cache[k(t)]}copy({cache:e}){return Object.keys(e).forEach(t=>{s(this.cache,t)?this.cache[t].copy(e[t]):this.cache[t]=e[t]}),this}}const j=e=>new O(e),V=Symbol("type-checkers::info"),S=e=>e?e[V]:void 0,_=(e,t)=>{e&&t&&(e[V]=t)};class N{constructor(e,t=null,r=!0,n=b(),s=j()){this.checker=e,this.data=t,this.deep=r,this.names=n,this.children=s}getChild(e){return this.children.get(e)}storeChildFrom(e,t){const r=S(t);r&&this.children.store(e,r)}createChildWithNames(e,t,r=null){const n=new N(this.checker,this.checker.init(t,r),this.deep,e);return this.children.store(e.lastName,n),n}createChild(e,t,r=null){return this.createChildWithNames(this.names.clone(e),t,r)}copy({deep:e,checker:t,children:r,data:n,names:s}){return this.checker===t?(this.deep=this.deep||e,this.children.copy(r),this.data=t.mergeConfigs(this.data,n,s)):console.error("TypeChecked objects can be merged only if using exactly same instance of type checker."),this}}var $=r(function(e,t){Object.defineProperty(t,"__esModule",{value:!0});const r=e=>"function"==typeof e;t.isFunction=r,t.default=r}),F=t($),x=($.isFunction,r(function(e,t){Object.defineProperty(t,"__esModule",{value:!0});const{isFunction:r}=$,n=e=>{const{apply:t,construct:n}=e;delete e.apply,delete e.construct;const s={...e,construct:n,apply:t};return t=>new Proxy(t,r(t)?s:e)};t.withProxy=n,t.default=n})),M=t(x);x.withProxy;const W=Symbol("type-checkers::target"),E=e=>Boolean(e&&e[W]),T=e=>(e=>{const t=typeof e;return Boolean(e)&&("function"===t||"object"===t)&&!f(e)})(e)&&!E(e),D=["wrapFunctionArguments","wrapFunctionReturnValues","ignorePrototypeMethods","wrapSetPropertyValues"],I=e=>(t,r)=>{const n=t[r];if(r===V)return n;if(r===W)return t;const a=S(t),{names:o,data:c,checker:u}=a,i=o.clone(r);return u.getProperty&&u.getProperty(t,i,n,c),!T(n)||((e,t,r,n)=>!(!F(n)||s(e,r)||!P("ignorePrototypeMethods",t)))(t,a,r,n)?n:((e,t,r,n)=>{const s=S(t),{deep:a}=s;if(a||F(n)){const{lastName:t}=r,a=s.getChild(t);return e(n,a||s.createChildWithNames(r,n))}return n})(e,t,i,n)},A=e=>(t,r,n)=>{if(r===W)throw new Error(`"${W}" is a virtual property and cannot be set`);if(r===V)return((e,t)=>{let r=S(e);return r&&t&&r!==t?r.copy(t):r=t,e[V]=r,!0})(t,n);const s=S(t);return T(n)&&P("wrapSetPropertyValues",s)?((e,t,r,n)=>{const s=S(t),{names:a,checker:o,data:c}=s,u=s.getChild(r),i=u?u.names:a.clone(r);return o.setProperty&&o.setProperty(t,i,n,c),n=e(n,u||s.createChildWithNames(i,n)),t[r]=n,!0})(e,t,r,n):((e,t,r)=>{const{names:n,data:s,checker:a}=S(e);return a.setProperty&&a.setProperty(e,n.clone(t),r,s),e[t]=r,!0})(t,r,n)},R=(e,t,r,n)=>{if(!T(n))return n;const s=t.getChild(r);return e(n,s||t.createChild(r,n))},B=(e,t,r)=>{if(P("wrapFunctionArguments",t)){const{length:n}=r;for(let s=0;s<n;s++)r[s]=R(e,t,String(s),r[s])}return r},q=(e,{checker:t=o(),deep:r,name:n,data:s,children:a,info:c=null}={})=>c||((e,t,r,n,s)=>new N(e,t,r,n,s))(t,t.init(e,s),r,b(n),a),z=(e,t=null)=>({get:(!t||t.get)&&I(e),set:(!t||t.set)&&A(e),apply:(!t||t.apply)&&(e=>(t,r,n)=>{const s=S(t),{names:a,data:o,checker:c}=s;c.arguments&&c.arguments(t,a,n,o,r),P("wrapFunctionArguments",s)&&(n=B(e,s,n));let u=t.apply(r,n);return c.returnValue&&c.returnValue(t,a,u,o,r),P("wrapFunctionReturnValues",s)&&(u=R(e,s,"returnValue",u)),u})(e),construct:(!t||t.construct)&&(e=>(t,r)=>{const n=S(t),{names:s,data:a,checker:o}=n;o.arguments&&o.arguments(t,s,r,a),P("wrapFunctionArguments",n)&&(r=B(e,n,r));let c=new t(...r);return o.returnValue&&o.returnValue(t,s,c,a),P("wrapFunctionReturnValues",n)&&(c=R(e,n,"returnValue",c)),c})(e),deleteProperty:(!t||t.deleteProperty)&&(()=>(e,t)=>{if(t===V)return delete e[t];if(t===W)return!1;const r=S(e),{names:n,data:s,checker:a}=r;return a.deleteProperty(e,n.clone(t),s),delete e[t]})()}),L=e=>{let t;const r=(e,r)=>(_(e,r),t(e)),n=z(r,e);return t=M(n),r},G=(e,t)=>{const{names:r,checker:n,data:s}=t;return Object.keys(e).forEach(a=>{const o=e[a],c=r.clone(a);if(n.getProperty&&n.getProperty(e,c,o,s),T(o)){let e=t.getChild(a);e||(e=t.createChildWithNames(c,o)),G(o,e)}}),_(e,t),t};e.getDefaultTypeChecker=o,e.setDefaultTypeChecker=c,e.isEnabled=u,e.setEnabled=i,e.addIgnoredClasses=d,e.isIgnoredClass=(e=>p.has(e)),e.isValueOfIgnoredClass=f,e.removeIgnoredClasses=((...e)=>{e.forEach(e=>p.delete(e))}),e.getWrapConfig=m,e.setWrapConfig=v,e.getWrapConfigValue=P,e.getTargetInfo=S,e.getTypeChecker=(e=>{if(e){const t=e[V];return t&&t.checker||void 0}}),e.getTypeCheckerData=(e=>{if(e){const t=e[V];return t&&t.data||void 0}}),e.removeTargetInfo=(e=>delete e[V]),e.wrap=((e,t=null,r=null)=>{if(!T(e)||!u())return e;return L(r)(e,q(e,t||void 0))}),e.wrapDeep=((e,t,r=null)=>{if(!T(e)||"object"!=typeof e||!u())return e;const n=L(r),s=q(e,t);return G(e,s),n(e,s)}),e.isWrappable=T,e.isWrapped=E,e.unwrap=(e=>e&&e[W]||e),e.setWrapConfigTo=((e,t)=>{if(!E(e)||!t)return;const r=S(e);D.forEach(e=>{s(e,t)&&(r[e]=t[e])})}),Object.defineProperty(e,"__esModule",{value:!0})});
//# sourceMappingURL=type-checkers.min.js.map
