!function(e,r){"object"==typeof exports&&"undefined"!=typeof module?r(exports):"function"==typeof define&&define.amd?define(["exports"],r):r(e.TypeCheckers={})}(this,function(e){"use strict";const r="GetProperty",t="SetProperty",n="Arguments",o="ReturnValue",c=e=>e.reduce((e,r)=>e=String(parseInt(r,10))===r?`${e}[${r}]`:/^[a-z][\w$]*$/i.test(r)?e?`${e}.${r}`:r:`${e}["${r}"]`,""),s=Symbol("type-checkers::info"),i=e=>e?e[s]:void 0,p=(e,r)=>{e&&r&&(e[s]=r)},a=e=>!!i(e),f=e=>e&&e[s]?e[s].config:void 0,u=(e={})=>Object.assign({},e),l=(e,r,t)=>{delete e[r],t&&(e[r]=t)},y=(e,r,t)=>{l(e,r,i(t))},g=(e,r)=>e[r],h=(e,r)=>{const{deep:t,checker:n,children:o,config:c,names:s}=e;return n===r.checker?(e.deep=t||r.deep,e.children=((e,r)=>{for(const t in r)e.hasOwnProperty(t)?e[t]=h(e[t],r[t]):e[t]=r[t];return e})(o,r.children),e.config=n.mergeConfigs(c,r.config,s)):console.error("TypeChecked objects can be merged only if using exactly same instance of type checker."),e},d=(e,r,t,n,o,s)=>{if(!n)return!0;const i=r[t];if(i){if(i!==n)return o(e,c([...s,t]),i,n),!1}else r[t]=n;return!0},k={collectTypesOnInit:!0,init(e,r,t=null){let n={};return t?n=t:this.collectTypesOnInit&&Object.keys(e).forEach(r=>{n[r]=this.getTypeString(e[r])}),{types:n,errorReporter:r}},getTypeString:e=>void 0===e?"":e instanceof Array?"array":typeof e,mergeConfigs({types:e,errorReporter:r},t,n=[]){const o=t.types;for(const t in o)if(o.hasOwnProperty(t)){const s=o[t],i=e[t];s&&i&&i!==s?r("Merge",c([...n,t]),i,s):e[t]=s}},replacePropertyTypeCheck(e,r,t){const{types:n}=f(e);delete n[r],t&&(n[r]=t)},replaceArgumentsTypeCheck(e,r,t){const{types:o}=f(e);delete o[n],t&&(o[r]=t)},replaceReturnValueTypeCheck(e,r,t){const{types:n}=f(e);delete n[o],t&&(n[o]=t)},getProperty(e,t,n,o,c){const{types:s,errorReporter:i}=o,p=s[t];if(p instanceof Function)return p(r,e,t,n,o,c);const a=this.getTypeString(n);return d(r,s,t,a,i,c)},setProperty(e,r,n,o,c){const{types:s,errorReporter:i}=o,p=s[r];if(p instanceof Function)return p(t,e,r,n,o,c);const a=this.getTypeString(n);return d(t,s,r,a,i,c)},arguments(e,r,t,o,c){const{types:s,errorReporter:i}=o,p=s[n];if(p instanceof Function)return p(n,e,t,o,c);const{length:a}=t;let f=!0;for(let e=0;e<a;e++){const r=this.getTypeString(t[e]);f=d(n,s,String(e),r,i,c)&&f}return f},returnValue(e,r,t,c,s){const{types:i,errorReporter:p}=c,a=i[o];if(a instanceof Function)return a(n,e,t,c,s);const f=this.getTypeString(t);return d(o,i,o,f,p,s)}};let m=k;const T=()=>m,P=(e,r,t,n)=>`${e}Error on "${r}" instead of "${t}" received "${n}"`,b=(e,r,t,n)=>console.error(P(e,r,t,n));let C=b;const w=()=>C;let R=!0;const j=()=>R,S={wrapFunctionReturnValues:!0,wrapFunctionArguments:!1,wrapSetPropertyValues:!0},$=Symbol("type-checkers::target"),v={object:!0,function:!0},E=e=>e&&v[typeof e],O=e=>Boolean(e&&e[$]);let F,V,x;const I=e=>e instanceof Function?new Proxy(e,{apply:x,construct:x}):new Proxy(e,{get:F,set:V});const A=(e,{deep:r=!0,names:t=[],config:n=null,children:o=null,checker:c=T(),info:s=null}={})=>s||((e,r,t=!0,n=[],o=u())=>({checker:e,config:r,deep:t,names:n,children:o}))(c,c.init(e,w(),n),r,t,u(o)),D=(e,r)=>E(e)&&j()&&!O(e)?(p(e,A(e,r)),I(e)):e;M=D,F=((e,r)=>{const t=e[r];if(r===s)return t;if(r===$)return e;const n=i(e),{names:o,config:c,checker:p}=n;return p.getProperty&&p.getProperty(e,r,t,c,o),!E(t)||O(t)?t:((e,r,t,n)=>{const o=i(r),{deep:c,children:s,names:p,checker:a}=o;if(c||n instanceof Function){const r=g(s,t);r?n=e(n,{info:r}):(n=e(n,{deep:c,names:[...p,t],checker:a}),y(s,t,n))}return n})(M,e,r,t)});var M;_=D,V=((e,r,t)=>{if(r===$)throw new Error(`"${$}" is a virtual property and cannot be set`);const{names:n,config:o,checker:c}=i(e);return c.setProperty&&c.setProperty(e,r,t,o,n),((e,r,t)=>{if(r===s){let n=i(e);return n=n&&t&&n!==t?h(n,t):t,e[r]=n,!0}return!E(t)&&(e[r]=t,!0)})(e,r,t)||((e,r,t,n)=>{if(S.wrapSetPropertyValues){const{deep:o,names:c,checker:s,children:p}=i(r);if(!O(n)){const r=g(p,t);n=e(n,r?{info:r}:{deep:o,names:[...c,t],checker:s})}y(p,t,n)}return r[t]=n,!0})(_,e,r,t)});var _;z=D,x=((e,r,t)=>{const n=i(e),{names:c,config:s,checker:p}=n;p.arguments&&p.arguments(e,r,t,s,c),t=((e,r,t)=>{if(S.wrapFunctionArguments){const{deep:n,names:o,checker:c}=i(r),{length:s}=t;for(let r=0;r<s;r++)t[r]=e(t[r],{deep:n,names:[...o,r],checker:c})}return t})(z,e,t);const a=e.apply(r,t);return p.returnValue&&p.returnValue(e,r,a,s,c),((e,r,t)=>{if(S.wrapFunctionReturnValues){const{deep:n,names:c,checker:s,children:p}=i(r);if(!O(t)){const r=g(p,o);t=e(t,r?{info:r}:{deep:n,names:[...c],checker:s})}y(p,o,t)}return t})(z,e,a)});var z;const B=(e,r)=>{const t=A(e,r),{deep:n,names:o,checker:c,config:s,children:i}=t;return Object.keys(e).forEach(r=>{const t=e[r];if(c.getProperty(e,r,t,s,o),"object"==typeof t){let e=g(i,r);e?B(t,{info:e}):(e=B(t,{deep:n,names:[...o,r],checker:c}),l(i,r,e))}}),p(e,t),t};e.PrimitiveTypeChecker=k,e.getDefaultTypeChecker=T,e.setDefaultTypeChecker=(e=>{m=e}),e.ConsoleErrorReporter=b,e.ConsoleWarnReporter=((e,r,t,n)=>console.warn(P(e,r,t,n))),e.ThrowErrorReporter=((e,r,t,n)=>{throw new Error(P(e,r,t,n))}),e.getErrorReporter=w,e.setErrorReporter=(e=>C=e),e.isEnabled=j,e.setEnabled=((e=!0)=>R=!!e),e.getTargetInfo=i,e.hasTargetInfo=a,e.setTargetInfo=p,e.getTargetTypeChecker=(e=>e&&e[s]?e[s].checker:void 0),e.getTargetTypeCheckerConfig=f,e.mergeTargetInfo=h,e.objectMerge=((e,...r)=>{let t={};return j()&&(e||(e={info:i(r.find(e=>a(e))),deep:!1}),t=D(t,e)),Object.assign(t,...r)}),e.getProxyConfig=(()=>Object.assign({},S)),e.setProxyConfig=(e=>Object.assign(S,e)),e.create=D,e.createDeep=((e,r)=>e&&"object"==typeof e&&j()&&!O(e)?(B(e,r),I(e)):e),e.isTypeChecked=O,e.isValidTarget=E,e.default=D,Object.defineProperty(e,"__esModule",{value:!0})});
//# sourceMappingURL=type-checkers.min.js.map
