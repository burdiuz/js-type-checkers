!function(e,r){"object"==typeof exports&&"undefined"!=typeof module?r(exports):"function"==typeof define&&define.amd?define(["exports"],r):r(e.TypeCheckers={})}(this,function(e){"use strict";let r=null;const t=()=>r;var n,o,c=(function(e,r){Object.defineProperty(r,"__esModule",{value:!0});const t=(e=>(r,t)=>Boolean(r&&e.call(r,t)))(Object.prototype.hasOwnProperty);r.hasOwn=t,r.default=t}(n={exports:{}},n.exports),n.exports),s=(o=c)&&o.__esModule&&Object.prototype.hasOwnProperty.call(o,"default")?o.default:o;c.hasOwn;const i=()=>({wrapFunctionReturnValues:!0,wrapFunctionArguments:!1,wrapSetPropertyValues:!0,ignorePrototypeMethods:!1}),a={wrapFunctionReturnValues:!0,wrapFunctionArguments:!1,wrapSetPropertyValues:!0,ignorePrototypeMethods:!1},l=(e,r=null)=>s(r,e)?r[e]:a[e],p=(e,r,t,n)=>`${e}Error on "${r}" instead of "${t}" received "${n}"`,u=(e,r,t,n)=>console.error(p(e,r,t,n));let f=u;const g=()=>f;let d=!0;const h=()=>d,y=Symbol("type-checkers::info"),P=(e={})=>Object.assign({},e),m=e=>e?e[y]:void 0,w=(e,r)=>{e&&r&&(e[y]=r)},O=e=>!!m(e),b=e=>`@${e}`,k=(e,r,t)=>{const n=b(r);delete e[n],t&&(e[n]=t)},T=(e,r,t)=>{k(e,r,m(t))},R=(e,r)=>e[b(r)],E=(e,r)=>{const{deep:t,checker:n,children:o,config:c,names:i}=e;return n===r.checker?(e.deep=t||r.deep,e.children=((e,r)=>{for(const t in r){const n=b(t);s(e,n)?e[n]=E(e[n],r[n]):e[n]=r[n]}return e})(o,r.children),e.config=n.mergeConfigs(c,r.config,i)):console.error("TypeChecked objects can be merged only if using exactly same instance of type checker."),e},j=Symbol("type-checkers::target"),_={object:!0,function:!0},C=e=>Boolean(e&&_[typeof e]),F=e=>Boolean(e&&e[j]),V=(e,r,t,n)=>{if(!C(n))return n;let o=n;if(!F(n)){const{children:c}=r,s=R(c,t);if(s)o=e(n,{info:s});else{const{deep:s,names:i,checker:a}=r;o=e(n,{deep:s,names:[...i,t],checker:a}),T(c,t,o)}}return o};let S,x,A;const M=e=>e instanceof Function?(e=>new Proxy(e,{get:S,set:x,apply:A,construct:A}))(e):(e=>new Proxy(e,{get:S,set:x}))(e),v=(e,{deep:r=!0,names:n=[],config:o=null,children:c=null,checker:s=t(),info:i=null}={})=>i||((e,r,t=!0,n=[],o=P())=>({checker:e,config:r,deep:t,names:n,children:o}))(s,s.init(e,g(),o),r,n,P(c)),I=(e,r)=>C(e)&&h()&&!F(e)?(w(e,v(e,r)),M(e)):e;S=(e=>(r,t)=>{const n=r[t];if(t===y)return n;if(t===j)return r;const o=m(r),{names:c,config:i,checker:a}=o;return a.getProperty&&a.getProperty(r,t,n,i,c),!C(n)||F(n)||((e,r,t,n)=>!!(n instanceof Function&&!s(e,t)&&l("ignorePrototypeMethods",r)))(r,o,t,n)?n:((e,r,t,n)=>{const o=m(r),{deep:c,children:s,names:i,checker:a}=o;if(c||n instanceof Function){const r=R(s,t);r?n=e(n,{info:r}):(n=e(n,{deep:c,names:[...i,t],checker:a}),T(s,t,n))}return n})(e,r,t,n)})(I),x=(e=>(r,t,n)=>{if(t===j)throw new Error(`"${j}" is a virtual property and cannot be set`);return((e,r,t)=>{if(r===y){let n=m(e);return n=n&&t&&n!==t?E(n,t):t,e[r]=n,!0}if(!C(t)){const{names:n,config:o,checker:c}=m(e);return c.setProperty&&c.setProperty(e,r,t,o,n),e[r]=t,!0}return!1})(r,t,n)||((e,r,t,n)=>{const o=m(r),{deep:c,names:s,checker:i,config:a,children:p}=o;if(i.setProperty&&i.setProperty(r,t,n,a,s),l("wrapSetPropertyValues",o)){if(!F(n)){const r=R(p,t);n=e(n,r?{info:r}:{deep:c,names:[...s,t],checker:i})}T(p,t,n)}return r[t]=n,!0})(e,r,t,n)})(I),A=(e=>(r,t,n)=>{const o=m(r),{names:c,config:s,checker:i}=o;i.arguments&&i.arguments(r,t,n,s,c),n=((e,r,t)=>{const n=m(r);if(l("wrapFunctionArguments",n)){const{length:r}=t;for(let o=0;o<r;o++)t[o]=V(e,n,String(o),t[o])}return t})(e,r,n);let a=r.apply(t,n);return i.returnValue&&i.returnValue(r,t,a,s,c),l("wrapFunctionReturnValues",o)&&(a=V(e,o,"returnValue",a)),a})(I);const N=(e,r)=>{const t=v(e,r),{deep:n,names:o,checker:c,config:s,children:i}=t;return Object.keys(e).forEach(r=>{const t=e[r];if(c.getProperty(e,r,t,s,o),"object"==typeof t){let e=R(i,r);e?N(t,{info:e}):(e=N(t,{deep:n,names:[...o,r],checker:c}),k(i,r,e))}}),w(e,t),t};e.getDefaultTypeChecker=t,e.setDefaultTypeChecker=(e=>{r=e}),e.PROXY_WRAP_FUNCTION_RETURN_VALUES="wrapFunctionReturnValues",e.PROXY_WRAP_FUNCTION_ARGUMENTS="wrapFunctionArguments",e.PROXY_WRAP_SET_PROPERTY_VALUES="wrapSetPropertyValues",e.PROXY_IGNORE_PROTOTYPE_METHODS="ignorePrototypeMethods",e.getDefaultProxyConfig=i,e.setProxyConfig=(e=>Object.assign(a,e)),e.getProxyConfig=(()=>Object.assign({},a)),e.create=I,e.createDeep=((e,r)=>e&&"object"==typeof e&&h()&&!F(e)?(N(e,r),M(e)):e),e.ConsoleErrorReporter=u,e.ConsoleWarnReporter=((e,r,t,n)=>console.warn(p(e,r,t,n))),e.ThrowErrorReporter=((e,r,t,n)=>{throw new Error(p(e,r,t,n))}),e.getErrorReporter=g,e.setErrorReporter=(e=>{f=e}),e.isEnabled=h,e.setEnabled=((e=!0)=>{d=!!e}),e.getTargetInfo=m,e.setTargetInfo=w,e.hasTargetInfo=O,e.getTargetTypeChecker=(e=>e&&e[y]?e[y].checker:void 0),e.getTargetTypeCheckerConfig=(e=>{if(e&&e[y])return e[y].config}),e.mergeTargetInfo=E,e.getOriginalTarget=(e=>e[j]||e),e.merge=((e,...r)=>{let t={};return h()&&(e||(e={info:m(r.find(e=>O(e))),deep:!1}),t=I(t,e)),Object.assign(t,...r)}),e.properties=((e,r,...t)=>{if(!h())return e;if(!C(e))throw new Error("Target must be a valid object.");if(Object.isFrozen(e)||Object.isSealed(e))throw new Error("Target object should not be sealed or frozen.");t.length||(t=Object.keys(e));const{length:n}=t;for(let o=0;o<n;o+=1){const n=t[o],{writable:c,get:s,set:i}=Object.getOwnPropertyDescriptor(e,n);if(s&&i||c){const t=e[n];C(t)&&!F(t)&&(e[n]=I(t,r))}}return e}),e.isTypeChecked=F,e.isValidTarget=C,e.default=I,Object.defineProperty(e,"__esModule",{value:!0})});
//# sourceMappingURL=type-checkers.min.js.map
