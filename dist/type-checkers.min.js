!function(e,r){"object"==typeof exports&&"undefined"!=typeof module?r(exports):"function"==typeof define&&define.amd?define(["exports"],r):r(e.TypeCheckers={})}(this,function(e){"use strict";const r="ReturnValue",t=e=>e.reduce((e,r)=>e=String(parseInt(r,10))===r?`${e}[${r}]`:/^[a-z][\w$]*$/i.test(r)?e?`${e}.${r}`:r:`${e}["${r}"]`,""),n=(e,r,n,o,c,s)=>{if(!o)return!0;const i=r[n];if(i){if(i!==o)return c(e,t([...s,n]),r[n],o),!1}else r[n]=o;return!0},o={collectTypesOnInit:!0,init(e,r,t=null){let n={};return t?n=t:this.collectTypesOnInit&&Object.keys(e).forEach(r=>{n[r]=this.getTypeString(e[r])}),{types:n,errorReporter:r}},getTypeString:e=>void 0===e?"":e instanceof Array?"array":typeof e,mergeConfigs({types:e,errorReporter:r},n,o=[]){const c=n.types;for(const n in c)if(c.hasOwnProperty(n)){const s=c[n],i=e[n];s&&i&&i!==s?r("Merge",t([...o,n]),i,s):e[n]=s}},getProperty(e,r,t,{types:o,errorReporter:c},s){return n("GetProperty",o,r,this.getTypeString(t),c,s)},setProperty(e,r,t,{types:o,errorReporter:c},s){return n("SetProperty",o,r,this.getTypeString(t),c,s)},arguments(e,r,t,{types:o,errorReporter:c},s){const{length:i}=t;let p=!0;for(let e=0;e<i;e++){p=n("Arguments",o,String(e),this.getTypeString(t[e]),c,s)&&p}return p},returnValue(e,t,o,{types:c,errorReporter:s},i){return n(r,c,"",this.getTypeString(o),s,i)}};let c=o;const s=()=>c,i=(e,r,t,n)=>`${e}Error on "${r}" instead of "${t}" received "${n}"`,p=(e,r,t,n)=>console.error(i(e,r,t,n));let a=p;const f=()=>a;let u=!0;const g=()=>u,l=Symbol("type-checkers::info"),y=e=>e?e[l]:void 0,h=(e,r)=>{e&&r&&(e[l]=r)},d=e=>!!y(e),m=(e={})=>Object.assign({},e),k=(e,r,t)=>{delete e[r],t&&(e[r]=t)},T=(e,r,t)=>{k(e,r,y(t))},b=(e,r)=>e[r],P=(e,r)=>{const{deep:t,checker:n,children:o,config:c,names:s}=e;return n===r.checker?(e.deep=t||r.deep,e.children=((e,r)=>{for(const t in r)e.hasOwnProperty(t)?e[t]=P(e[t],r[t]):e[t]=r[t];return e})(o,r.children),e.config=n.mergeConfigs(c,r.config,s)):console.error("TypeChecked objects can be merged only if using exactly same instance of type checker."),e},w={wrapFunctionReturnValues:!0,wrapFunctionArguments:!1,wrapSetPropertyValues:!0},C=Symbol("type-checkers::target"),R={object:!0,function:!0},j=e=>e&&R[typeof e],S=e=>Boolean(e&&e[C]);let $,v,E;const O=e=>e instanceof Function?new Proxy(e,{apply:E,construct:E}):new Proxy(e,{get:$,set:v});const V=(e,{deep:r=!0,names:t=[],config:n=null,children:o=null,checker:c=s(),info:i=null}={})=>i||((e,r,t=!0,n=[],o=m())=>({checker:e,config:r,deep:t,names:n,children:o}))(c,c.init(e,f(),n),r,t,m(o)),x=(e,r)=>j(e)&&g()&&!S(e)?(h(e,V(e,r)),O(e)):e;I=x,$=((e,r)=>{const t=e[r];if(r===l)return t;if(r===C)return e;const n=y(e),{names:o,config:c,checker:s}=n;return s.getProperty&&s.getProperty(e,r,t,c,o),!j(t)||S(t)?t:((e,r,t,n)=>{const o=y(r),{deep:c,children:s,names:i,checker:p}=o;if(c||n instanceof Function){const r=b(s,t);r?n=e(n,{info:r}):(n=e(n,{deep:c,names:[...i,t],checker:p}),T(s,t,n))}return n})(I,e,r,t)});var I;F=x,v=((e,r,t)=>{if(r===C)throw new Error(`"${C}" is a virtual property and cannot be set`);const{names:n,config:o,checker:c}=y(e);return c.setProperty&&c.setProperty(e,r,t,o,n),((e,r,t)=>{if(r===l){let n=y(e);return n=n&&t&&n!==t?P(n,t):t,e[r]=n,!0}return!j(t)&&(e[r]=t,!0)})(e,r,t)||((e,r,t,n)=>{if(w.wrapSetPropertyValues){const{deep:o,names:c,checker:s,children:i}=y(r);if(!S(n)){const r=b(i,t);n=e(n,r?{info:r}:{deep:o,names:[...c,t],checker:s})}T(i,t,n)}return r[t]=n,!0})(F,e,r,t)});var F;A=x,E=((e,t,n)=>{const o=y(e),{names:c,config:s,checker:i}=o;i.arguments&&i.arguments(e,t,n,s,c),n=((e,r,t)=>{if(w.wrapFunctionArguments){const{deep:n,names:o,checker:c}=y(r),{length:s}=t;for(let r=0;r<s;r++)t[r]=e(t[r],{deep:n,names:[...o,r],checker:c})}return t})(A,e,n);const p=e.apply(t,n);return i.returnValue&&i.returnValue(e,t,p,s,c),((e,t,n)=>{if(w.wrapFunctionReturnValues){const{deep:o,names:c,checker:s,children:i}=y(t);if(!S(n)){const t=b(i,r);n=e(n,t?{info:t}:{deep:o,names:[...c],checker:s})}T(i,r,n)}return n})(A,e,p)});var A;const D=(e,r)=>{const t=V(e,r),{deep:n,names:o,checker:c,config:s,children:i}=t;return Object.keys(e).forEach(r=>{const t=e[r];if(c.getProperty(e,r,t,s,o),"object"==typeof t){let e=b(i,r);e?D(t,{info:e}):(e=D(t,{deep:n,names:[...o,r],checker:c}),k(i,r,e))}}),h(e,t),t};e.PrimitiveTypeChecker=o,e.getDefaultTypeChecker=s,e.setDefaultTypeChecker=(e=>c=e),e.ConsoleErrorReporter=p,e.ConsoleWarnReporter=((e,r,t,n)=>console.warn(i(e,r,t,n))),e.ThrowErrorReporter=((e,r,t,n)=>{throw new Error(i(e,r,t,n))}),e.getErrorReporter=f,e.setErrorReporter=(e=>a=e),e.isEnabled=g,e.setEnabled=((e=!0)=>u=!!e),e.getTargetInfo=y,e.hasTargetInfo=d,e.setTargetInfo=h,e.getTargetTypeChecker=(e=>e&&e[l]?e[l].checker:void 0),e.getTargetTypeCheckerConfig=(e=>e&&e[l]?e[l].config:void 0),e.mergeTargetInfo=P,e.objectMerge=((e,...r)=>{let t={};return g()&&(e||(e={info:y(r.find(e=>d(e))),deep:!1}),t=x(t,e)),Object.assign(t,...r)}),e.getProxyConfig=(()=>Object.assign({},w)),e.setProxyConfig=(e=>Object.assign(w,e)),e.create=x,e.createDeep=((e,r)=>e&&"object"==typeof e&&g()&&!S(e)?(D(e,r),O(e)):e),e.isTypeChecked=S,e.isValidTarget=j,e.default=x,Object.defineProperty(e,"__esModule",{value:!0})});
//# sourceMappingURL=type-checkers.min.js.map
