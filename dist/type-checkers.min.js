!function(e,r){"object"==typeof exports&&"undefined"!=typeof module?r(exports):"function"==typeof define&&define.amd?define(["exports"],r):r(e.TypeCheckers={})}(this,function(e){"use strict";const r="ReturnValue",t=e=>e.reduce((e,r)=>e=String(parseInt(r,10))===r?`${e}[${r}]`:/^[a-z][\w$]*$/i.test(r)?e?`${e}.${r}`:r:`${e}["${r}"]`,""),n=(e,r,n,o,s,c)=>{if(!o)return!0;const i=r[n];if(i){if(i!==o)return s(e,t([...c,n]),r[n],o),!1}else r[n]=o;return!0};let o={collectTypesOnInit:!0,init(e,r,t=null){let n={};return t?n=t:this.collectTypesOnInit&&Object.keys(e).forEach(r=>{n[r]=this.getTypeString(e[r])}),{types:n,errorReporter:r}},getTypeString:e=>void 0===e?"":e instanceof Array?"array":typeof e,mergeConfigs({types:e,errorReporter:r},n,o=[]){const s=n.types;for(const n in s){const c=s[n],i=e[n];c&&i&&i!==c?r("Merge",t([...o,n]),i,c):e[n]=c}},getProperty(e,r,t,{types:o,errorReporter:s},c){return n("GetProperty",o,r,this.getTypeString(t),s,c)},setProperty(e,r,t,{types:o,errorReporter:s},c){return n("SetProperty",o,r,this.getTypeString(t),s,c)},arguments(e,r,t,{types:o,errorReporter:s},c){const{length:i}=t;let p=!0;for(let e=0;e<i;e++){p=n("Arguments",o,String(e),this.getTypeString(t[e]),s,c)&&p}return p},returnValue(e,t,o,{types:s,errorReporter:c},i){return n(r,s,"",this.getTypeString(o),c,i)}};const s=()=>o,c=(e,r,t,n)=>`${e}Error on "${r}" instead of "${t}" received "${n}"`,i=(e,r,t,n)=>console.error(c(e,r,t,n));let p=i;const a=()=>p;let g=!0;const l=()=>g,f=Symbol("type-checkers::info"),u=e=>e[f],y=(e,r)=>e[f]=r,h=(e={})=>Object.assign({},e),d=(e,r,t)=>{m=e,T=r,k=u(t),m[T]=k};var m,T,k;const P=(e,r)=>e[r],w=(e,r)=>{const{checker:t,children:n,config:o,names:s}=e;return t===r.checker?(e.children=((e,r)=>{for(const t in r)e.hasOwnProperty(t)?e[t]=w(e[t],r[t]):e[t]=r[t];return e})(n,r.children),e.config=t.mergeConfigs(o,r.config,s)):console.error("TypeChecked objects can be merged only if using exactly same instance of type checker."),e},C={wrapFunctionReturnValues:!0,wrapFunctionArguments:!1,wrapSetPropertyValues:!0},R={object:!0,function:!0},b=e=>e&&R[typeof e],S=e=>!!u(e),$=(e,r)=>{let t=e[r];if(r===f)return t;const n=u(e),{deep:o,names:s,config:c,checker:i}=n;if(i.getProperty&&i.getProperty(e,r,t,c,s),!b(t)||S(t))return t;if(o||t instanceof Function){const{children:e}=n,c=P(e,name);c?t=j(t,{info:c},i):(t=j(t,{deep:o,names:[...s,r]},i),d(e,name,t))}return t},E=(e,r,t)=>{const n=u(e),{deep:o,names:s,config:c,checker:i}=n;if(r!==f&&(i.setProperty&&i.setProperty(e,r,t,c,s),C.wrapSetPropertyValues)){const{children:e}=n;if(!S(t)){const n=P(e,name);t=j(t,n?{info:n}:{deep:o,names:[...s,r]},i)}d(e,name,t)}e[r]=t},V=(e,t,n)=>{const o=u(e),{deep:s,names:c,config:i,checker:p}=o;if(p.arguments&&p.arguments(e,t,n,i,c),C.wrapFunctionArguments){const{length:e}=n;for(let r=0;r<e;r++)n[r]=j(n[r],{deep:s,names:[...c,r]},p)}let a=e.apply(t,n);if(p.returnValue&&p.returnValue(e,t,a,i,c),C.wrapFunctionReturnValues){const{children:e}=o;if(!S(a)){const t=P(e,r);a=j(a,t?{info:t}:{deep:s,names:[...c]},p)}d(e,r,a)}return a},j=(e,{deep:r=!0,names:t=[],config:n=null,children:o=null,info:c=null}={},i=s())=>b(e)&&l()&&!S(e)?(y(e,c||((e,r,t=!0,n=[],o=h())=>({checker:e,config:r,deep:t,names:n,children:o}))(i,i.init(e,a(),n),r,t,h(o))),e instanceof Function?new Proxy(e,{apply:V,construct:V}):new Proxy(e,{get:$,set:E})):e;e.getDefaultTypeChecker=s,e.setDefaultTypeChecker=(e=>o=e),e.ConsoleErrorReporter=i,e.ConsoleWarnReporter=((e,r,t,n)=>console.warn(c(e,r,t,n))),e.ThrowErrorReporter=((e,r,t,n)=>{throw new Error(c(e,r,t,n))}),e.getErrorReporter=a,e.setErrorReporter=(e=>p=e),e.isEnabled=l,e.setEnabled=((e=!0)=>g=!!e),e.getTargetTypeChecker=(e=>u(e).checker),e.getTargetTypeCheckerConfig=(e=>u(e).config),e.assignTargetInfo=((e,...r)=>{const{length:t}=r;for(let n=0;n<t;n++){const t=r[n];t&&(e=e?w(e,t):t)}return e}),e.assignTargetInfoFrom=((e,...r)=>{const{length:t}=r;let n=u(e);for(let e=0;e<t;e++){const t=r[e];t&&(n=n?w(n,t):t)}return y(e,n),e}),e.mergeTargetInfo=w,e.getProxyConfig=(()=>Object.assign({},C)),e.setProxyConfig=(e=>Object.assign(C,e)),e.create=j,e.createDeep=(()=>{}),e.isTypeChecked=S,e.isValidTarget=b,e.default=j,Object.defineProperty(e,"__esModule",{value:!0})});
//# sourceMappingURL=type-checkers.min.js.map
