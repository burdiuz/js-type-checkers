!function(e,r){"object"==typeof exports&&"undefined"!=typeof module?r(exports):"function"==typeof define&&define.amd?define(["exports"],r):r(e.TypeCheckers={})}(this,function(e){"use strict";const r="(GetProperty)",t="(SetProperty)",n="(Index)",o="(Arguments)",s="(ReturnValue)";function c(e){if(!(this instanceof c))return new c(e);this.value=e}function i(){return this.value}c.prototype.toString=i,c.prototype.valueOf=i,c.prototype[Symbol.toPrimitive]=i;const p=e=>e.reduce((e,r)=>e=r instanceof c?`${e}${r}`:String(parseInt(r,10))===r?`${e}[${r}]`:/^[a-z][\w$]*$/i.test(r)?e?`${e}.${r}`:r:`${e}["${r}"]`,""),a=Symbol("type-checkers::info"),f=e=>e?e[a]:void 0,u=(e,r)=>{e&&r&&(e[a]=r)},y=e=>!!f(e),l=e=>{if(e&&e[a])return e[a].config},d=(e={})=>Object.assign({},e),g=(e,r,t)=>{delete e[r],t&&(e[r]=t)},h=(e,r,t)=>{g(e,r,f(t))},m=(e,r)=>e[r],P=(e,r)=>{const{deep:t,checker:n,children:o,config:s,names:c}=e;return n===r.checker?(e.deep=t||r.deep,e.children=((e,r)=>{for(const t in r)e.hasOwnProperty(t)?e[t]=P(e[t],r[t]):e[t]=r[t];return e})(o,r.children),e.config=n.mergeConfigs(s,r.config,c)):console.error("TypeChecked objects can be merged only if using exactly same instance of type checker."),e},k=(e,r,t,n,o,s)=>{if(!n)return!0;const c=r[t];if(c){if(c!==n)return o(e,p([...s,t]),c,n),!1}else r[t]=n;return!0},T=[Array],b=e=>e&&T.indexOf(e.constructor)>=0,C=e=>void 0===e?"":e instanceof Array?"array":typeof e,O=(e,r)=>{const t=l(e);t&&(t.types[n]=r)},x={collectTypesOnInit:!0,areArrayElementsOfSameType:!0,init(e,r,t=null){let o={};if(t)o=t;else if(this.collectTypesOnInit)if(this.areArrayElementsOfSameType&&e instanceof Array){const r=C(e.find(e=>void 0!==e));r&&(o[n]=r)}else Object.keys(e).forEach(r=>{o[r]=C(e[r])});return{types:o,errorReporter:r}},getProperty(e,r,t,o,s){return this.areArrayElementsOfSameType&&b(e)?this.getIndexProperty(e,n,t,o,s):this.getNamedProperty(e,r,t,o,s)},getIndexProperty(e,t,o,s,i){const{types:p,errorReporter:a}=s,f=p[t];if(f instanceof Function)return f(r,e,t,o,s,i);const u=C(o);return k(r,p,c(n),u,a,i)},getNamedProperty(e,t,n,o,s){const{types:c,errorReporter:i}=o,p=c[t];if(p instanceof Function)return p(r,e,t,n,o,s);const a=C(n);return k(r,c,t,a,i,s)},setProperty(e,r,t,o,s){return this.areArrayElementsOfSameType&&b(e)?this.setIndexProperty(e,n,t,o,s):this.setNamedProperty(e,r,t,o,s)},setIndexProperty(e,r,o,s,i){const{types:p,errorReporter:a}=s,f=p[r];if(f instanceof Function)return f(t,e,r,o,s,i);const u=C(o);return k(t,p,c(n),u,a,i)},setNamedProperty(e,r,n,o,s){const{types:c,errorReporter:i}=o,p=c[r];if(p instanceof Function)return p(t,e,r,n,o,s);const a=C(n);return k(t,c,r,a,i,s)},arguments(e,r,t,n,s){const{types:c,errorReporter:i}=n,p=c[o];if(p instanceof Function)return p(o,e,t,n,s);const{length:a}=t;let f=!0;for(let e=0;e<a;e++){const r=C(t[e]);f=k(o,c,String(e),r,i,s)&&f}return f},returnValue(e,r,t,n,o){const{types:i,errorReporter:p}=n,a=i[s];if(a instanceof Function)return a(s,e,t,n,o);const f=C(t);return k(s,i,c(s),f,p,o)},isIndexAccessTarget:b,getTypeString:C,mergeConfigs:({types:e,errorReporter:r},t,n=[])=>{const o=t.types;for(const t in o)if(o.hasOwnProperty(t)){const s=o[t],c=e[t];s&&c&&c!==s?r("(Merge)",p([...n,t]),c,s):e[t]=s}return{types:e,errorReporter:r}},replacePropertyTypeCheck:(e,r,t)=>{const{types:n}=l(e);delete n[r],t&&(n[r]=t)},replaceArgumentsTypeCheck:(e,r)=>{const{types:t}=l(e);delete t[o],r&&(t[o]=r)},replaceReturnValueTypeCheck:(e,r)=>{const{types:t}=l(e);delete t[s],r&&(t[s]=r)},registerIndexBasedClass:e=>{T.push(e)},setIndexValueType:O,setIndexValueTypeBy:(e,r)=>{O(e,C(r))},replaceIndexedTypeCheck:(e,r)=>{const{types:t}=l(e);delete t[n],r&&(t[n]=r)}};let w=x;const I=()=>w,R=(e,r,t,n)=>`${e}Error on "${r}" instead of "${t}" received "${n}"`,v=(e,r,t,n)=>console.error(R(e,r,t,n));let E=v;const $=()=>E;let S=!0;const j=()=>S,A=Symbol("type-checkers::target"),F="wrapFunctionReturnValues",V="wrapFunctionArguments",B="wrapSetPropertyValues",M="ignorePrototypeMethods",N={[F]:!0,[V]:!1,[B]:!0,[M]:!1},D=(e,r=null)=>r&&r.hasOwnProperty(e)?r[e]:N[e],_={object:!0,function:!0},z=e=>Boolean(e&&_[typeof e]),G=e=>Boolean(e&&e[A]);var W,q,H,J;const K=(e,r,t,n)=>{if(!z(n))return n;let o=n;if(!G(n)){const{children:s}=r,c=m(s,t);if(c)o=e(n,{info:c});else{const{deep:c,names:i,checker:p}=r;o=e(n,{deep:c,names:[...i,t],checker:p}),h(s,t,o)}}return o};let L,Q,U;const X=e=>e instanceof Function?new Proxy(e,{get:L,set:Q,apply:U,construct:U}):new Proxy(e,{get:L,set:Q});const Y=(e,{deep:r=!0,names:t=[],config:n=null,children:o=null,checker:s=I(),info:c=null}={})=>c||((e,r,t=!0,n=[],o=d())=>({checker:e,config:r,deep:t,names:n,children:o}))(s,s.init(e,$(),n),r,t,d(o)),Z=(e,r)=>z(e)&&j()&&!G(e)?(u(e,Y(e,r)),X(e)):e;ee=Z,L=((e,r)=>{const t=e[r];if(r===a)return t;if(r===A)return e;const n=f(e),{names:o,config:s,checker:c}=n;return c.getProperty&&c.getProperty(e,r,t,s,o),!z(t)||G(t)||(W=e,q=n,H=r,J=t,J instanceof Function&&!W.hasOwnProperty(H)&&D(M,q))?t:((e,r,t,n)=>{const o=f(r),{deep:s,children:c,names:i,checker:p}=o;if(s||n instanceof Function){const r=m(c,t);r?n=e(n,{info:r}):(n=e(n,{deep:s,names:[...i,t],checker:p}),h(c,t,n))}return n})(ee,e,r,t)});var ee;re=Z,Q=((e,r,t)=>{if(r===A)throw new Error(`"${A}" is a virtual property and cannot be set`);return((e,r,t)=>{if(r===a){let n=f(e);return n=n&&t&&n!==t?P(n,t):t,e[r]=n,!0}if(!z(t)){const{names:n,config:o,checker:s}=f(e);return s.setProperty&&s.setProperty(e,r,t,o,n),e[r]=t,!0}return!1})(e,r,t)||((e,r,t,n)=>{const o=f(r),{deep:s,names:c,checker:i,config:p,children:a}=o;if(i.setProperty&&i.setProperty(r,t,n,p,c),D(B,o)){if(!G(n)){const r=m(a,t);n=e(n,r?{info:r}:{deep:s,names:[...c,t],checker:i})}h(a,t,n)}return r[t]=n,!0})(re,e,r,t)});var re;te=Z,U=((e,r,t)=>{const n=f(e),{names:o,config:i,checker:p}=n;p.arguments&&p.arguments(e,r,t,i,o),t=((e,r,t)=>{const n=f(r);if(D(V,n)){const{length:r}=t;for(let o=0;o<r;o++)t[o]=K(e,n,String(o),t[o])}return t})(te,e,t);let a=e.apply(r,t);return p.returnValue&&p.returnValue(e,r,a,i,o),D(F,n)&&(a=K(te,n,new c(s),a)),a});var te;const ne=(e,r)=>{const t=Y(e,r),{deep:n,names:o,checker:s,config:c,children:i}=t;return Object.keys(e).forEach(r=>{const t=e[r];if(s.getProperty(e,r,t,c,o),"object"==typeof t){let e=m(i,r);e?ne(t,{info:e}):(e=ne(t,{deep:n,names:[...o,r],checker:s}),g(i,r,e))}}),u(e,t),t};e.PrimitiveTypeChecker=x,e.getDefaultTypeChecker=I,e.setDefaultTypeChecker=(e=>{w=e}),e.ConsoleErrorReporter=v,e.ConsoleWarnReporter=((e,r,t,n)=>console.warn(R(e,r,t,n))),e.ThrowErrorReporter=((e,r,t,n)=>{throw new Error(R(e,r,t,n))}),e.getErrorReporter=$,e.setErrorReporter=(e=>E=e),e.isEnabled=j,e.setEnabled=((e=!0)=>{S=!!e}),e.getTargetInfo=f,e.hasTargetInfo=y,e.setTargetInfo=u,e.getTargetTypeChecker=(e=>e&&e[a]?e[a].checker:void 0),e.getTargetTypeCheckerConfig=l,e.mergeTargetInfo=P,e.getOriginalTarget=(e=>e[A]||e),e.objectMerge=((e,...r)=>{let t={};return j()&&(e||(e={info:f(r.find(e=>y(e))),deep:!1}),t=Z(t,e)),Object.assign(t,...r)}),e.replaceProperty=((e,r,t)=>{const n=e[r];return j()&&z(n)&&G(n),e}),e.getProxyConfig=(()=>Object.assign({},N)),e.setProxyConfig=(e=>Object.assign(N,e)),e.create=Z,e.createDeep=((e,r)=>e&&"object"==typeof e&&j()&&!G(e)?(ne(e,r),X(e)):e),e.isTypeChecked=G,e.isValidTarget=z,e.default=Z,Object.defineProperty(e,"__esModule",{value:!0})});
//# sourceMappingURL=type-checkers.min.js.map
