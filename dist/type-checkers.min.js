!function(e,r){"object"==typeof exports&&"undefined"!=typeof module?r(exports):"function"==typeof define&&define.amd?define(["exports"],r):r(e.TypeCheckers={})}(this,function(e){"use strict";const r="ReturnValue",t=e=>e.reduce((e,r)=>e=String(parseInt(r,10))===r?`${e}[${r}]`:/^[a-z][\w$]*$/i.test(r)?e?`${e}.${r}`:r:`${e}["${r}"]`,""),n=(e,r,n,o,c,s)=>{if(!o)return!0;const i=r[n];if(i){if(i!==o)return c(e,t([...s,n]),r[n],o),!1}else r[n]=o;return!0};let o={collectTypesOnInit:!0,init(e,r,t=null){let n={};return t?n=t:this.collectTypesOnInit&&Object.keys(e).forEach(r=>{n[r]=this.getTypeString(e[r])}),{types:n,errorReporter:r}},getTypeString:e=>void 0===e?"":e instanceof Array?"array":typeof e,mergeConfigs({types:e,errorReporter:r},n,o=[]){const c=n.types;for(const n in c){const s=c[n],i=e[n];s&&i&&i!==s?r("Merge",t([...o,n]),i,s):e[n]=s}},getProperty(e,r,t,{types:o,errorReporter:c},s){return n("GetProperty",o,r,this.getTypeString(t),c,s)},setProperty(e,r,t,{types:o,errorReporter:c},s){return n("SetProperty",o,r,this.getTypeString(t),c,s)},arguments(e,r,t,{types:o,errorReporter:c},s){const{length:i}=t;let p=!0;for(let e=0;e<i;e++){p=n("Arguments",o,String(e),this.getTypeString(t[e]),c,s)&&p}return p},returnValue(e,t,o,{types:c,errorReporter:s},i){return n(r,c,"",this.getTypeString(o),s,i)}};const c=()=>o,s=(e,r,t,n)=>`${e}Error on "${r}" instead of "${t}" received "${n}"`,i=(e,r,t,n)=>console.error(s(e,r,t,n));let p=i;const a=()=>p;let f=!0;const u=()=>f,g=Symbol("type-checkers::info"),l=e=>e?e[g]:void 0,y=(e,r)=>{e&&r&&(e[g]=r)},d=e=>!!l(e),h=(e={})=>Object.assign({},e),m=(e,r,t)=>{k=e,T=r,b=l(t),delete k[T],b&&(k[T]=b)};var k,T,b;const w=(e,r)=>e[r],P=(e,r)=>{const{deep:t,checker:n,children:o,config:c,names:s}=e;return n===r.checker?(e.deep=t||r.deep,e.children=((e,r)=>{for(const t in r)e.hasOwnProperty(t)?e[t]=P(e[t],r[t]):e[t]=r[t];return e})(o,r.children),e.config=n.mergeConfigs(c,r.config,s)):console.error("TypeChecked objects can be merged only if using exactly same instance of type checker."),e},C={wrapFunctionReturnValues:!0,wrapFunctionArguments:!1,wrapSetPropertyValues:!0},R=Symbol("type-checkers::target"),j={object:!0,function:!0},S=e=>e&&j[typeof e],$=e=>Boolean(e&&e[R]),E=(e,r)=>{let t=e[r];if(r===g)return t;if(r===R)return e;const n=l(e),{deep:o,names:c,config:s,checker:i}=n;if(i.getProperty&&i.getProperty(e,r,t,s,c),!S(t)||$(t))return t;if(o||t instanceof Function){const{children:e}=n,s=w(e,r);s?t=x(t,{info:s}):(t=x(t,{deep:o,names:[...c,r],checker:i}),m(e,r,t))}return t},O=(e,r,t)=>{if(r===R)throw new Error(`"${R}" is a virtual property and cannot be set`);let n=l(e);const{deep:o,names:c,config:s,checker:i}=n;if(i.setProperty&&i.setProperty(e,r,t,s,c),r===g)return n=n&&t&&n!==t?P(n,t):t,e[r]=n,!0;if(!S(t))return e[r]=t,!0;if(C.wrapSetPropertyValues){const{children:e}=n;if(!$(t)){const n=w(e,r);t=x(t,n?{info:n}:{deep:o,names:[...c,r],checker:i})}m(e,r,t)}return e[r]=t,!0},V=(e,t,n)=>{const o=l(e),{deep:c,names:s,config:i,checker:p}=o;if(p.arguments&&p.arguments(e,t,n,i,s),C.wrapFunctionArguments){const{length:e}=n;for(let r=0;r<e;r++)n[r]=x(n[r],{deep:c,names:[...s,r],checker:p})}let a=e.apply(t,n);if(p.returnValue&&p.returnValue(e,t,a,i,s),C.wrapFunctionReturnValues){const{children:e}=o;if(!$(a)){const t=w(e,r);a=x(a,t?{info:t}:{deep:c,names:[...s],checker:p})}m(e,r,a)}return a},v=e=>e instanceof Function?new Proxy(e,{apply:V,construct:V}):new Proxy(e,{get:E,set:O});const x=(e,{deep:r=!0,names:t=[],config:n=null,children:o=null,checker:s=c(),info:i=null}={})=>S(e)&&u()&&!$(e)?(y(e,i||((e,r,t=!0,n=[],o=h())=>({checker:e,config:r,deep:t,names:n,children:o}))(s,s.init(e,a(),n),r,t,h(o))),v(e)):e,I=e=>{for(const r in e){const t=e[r];"object"==typeof t&&I(t)}};e.getDefaultTypeChecker=c,e.setDefaultTypeChecker=(e=>o=e),e.ConsoleErrorReporter=i,e.ConsoleWarnReporter=((e,r,t,n)=>console.warn(s(e,r,t,n))),e.ThrowErrorReporter=((e,r,t,n)=>{throw new Error(s(e,r,t,n))}),e.getErrorReporter=a,e.setErrorReporter=(e=>p=e),e.isEnabled=u,e.setEnabled=((e=!0)=>f=!!e),e.getTargetInfo=l,e.hasTargetInfo=d,e.setTargetInfo=y,e.getTargetTypeChecker=(e=>e&&e[g]?e[g].checker:void 0),e.getTargetTypeCheckerConfig=(e=>e&&e[g]?e[g].config:void 0),e.mergeTargetInfo=P,e.objectMerge=((e,...r)=>{let t={};return u()&&(e||(e={info:l(r.find(e=>d(e))),deep:!1}),t=x(t,e)),Object.assign(t,...r)}),e.getProxyConfig=(()=>Object.assign({},C)),e.setProxyConfig=(e=>Object.assign(C,e)),e.create=x,e.createDeep=((e,r)=>{if(!e||"object"!==e||!u()||$(e))return e;const t=x(e,Object.assign({},r,{deep:!0}));return I(t),t}),e.isTypeChecked=$,e.isValidTarget=S,e.default=x,Object.defineProperty(e,"__esModule",{value:!0})});
//# sourceMappingURL=type-checkers.min.js.map
