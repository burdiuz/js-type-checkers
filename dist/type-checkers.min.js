!function(e,t){"object"==typeof exports&&"undefined"!=typeof module?t(exports):"function"==typeof define&&define.amd?define(["exports"],t):t(e.TypeCheckers={})}(this,function(e){"use strict";function t(e){return e&&e.__esModule&&Object.prototype.hasOwnProperty.call(e,"default")?e.default:e}function r(e,t){return e(t={exports:{}},t.exports),t.exports}var n=r(function(e,t){Object.defineProperty(t,"__esModule",{value:!0});const r=(e=>(t,r)=>Boolean(t&&e.call(t,r)))(Object.prototype.hasOwnProperty);t.hasOwn=r,t.default=r}),s=t(n);n.hasOwn;const a=(e=null,t)=>{let r=e;return{get:()=>r,set:(n=e)=>{r=t?t(n):n}}},{get:o,set:c}=a(),{get:i,set:u}=a(!0,e=>!!e);var l=r(function(e,t){Object.defineProperty(t,"__esModule",{value:!0});const r=e=>{if(null!==e&&void 0!==e)return e.constructor};t.getClass=r,t.default=r});t(l);var h=l.getClass;const p=new Set,d=(...e)=>{e.forEach(e=>{e&&!p.has(e)&&p.add(e)})},f=e=>p.has(h(e));d(Map,Set,Date,Error);const{values:g,getDefault:y,get:m,set:v,getValue:w}=((e={},t)=>{const r=()=>Object.assign({},e),n=r();return{values:n,getDefault:r,set:e=>Object.assign(n,t?t(e):e),get:()=>Object.assign({},n),getValue:e=>s(n,e)?n[e]:void 0}})({wrapFunctionReturnValues:!0,wrapFunctionArguments:!1,wrapSetPropertyValues:!0,ignorePrototypeMethods:!1},e=>Object.keys(e).forEach(t=>{e[t]=!!e[t]})),C=(e,t)=>{let r=t[e];return t&&(r=t[e]),void 0===r?w(e):r};var P=r(function(e,t){function r(e){if(!(this instanceof r))return new r(e);this.value=e}function n(){return this.value}Object.defineProperty(t,"__esModule",{value:!0}),r.prototype.toString=n,r.prototype.valueOf=n,r.prototype[Symbol.toPrimitive]=n;const s=(e,t)=>{const n=String(e)||"";return t instanceof r?`${n}${t}`:String(parseInt(t,10))===t?`${n}[${t}]`:/^[a-z_$][\w\d$_]*$/i.test(t)?n?`${n}.${t}`:t:`${n}["${t}"]`};class a{constructor(e){this.value=e?String(e):"",this.lastName=void 0}append(e){this.value=s(this.value,e),this.lastName=e}appendCustomValue(e){this.value=s(this.value,r(e)),this.lastName=e}clone(e){const t=new a(this.value);return void 0===e?t.lastName=this.lastName:t.append(e),t}getLastName(){return this.lastName}toString(){return this.value}valueOf(){return this.value}}t.createPathSequence=(e=>new a(e)),t.default=a});t(P);var b=P.createPathSequence;const k=e=>`@${e}`;const O=e=>new class{constructor(e){this.cache=e?Object.assign({},e.cache):{}}store(e,t){const r=k(e);t?this.cache[r]=t:delete this.cache[r]}get(e){return this.cache[k(e)]}has(e){return!!this.cache[k(e)]}remove(e,t){return delete this.cache[k(t)]}copy({cache:e}){return Object.keys(e).forEach(t=>{s(this.cache,t)?this.cache[t].copy(e[t]):this.cache[t]=e[t]}),this}}(e),j=Symbol("type-checkers::info"),V=e=>e?e[j]:void 0,_=(e,t)=>{e&&t&&(e[j]=t)};class S{constructor(e,t=null,r=!0,n=b(),s=O()){this.checker=e,this.data=t,this.deep=r,this.names=n,this.children=s}getChild(e){return this.children.get(e)}storeChildFrom(e,t){const r=V(t);r&&this.children.store(e,r)}createChildWithNames(e,t,r=null){const n=new S(this.checker,this.checker.init(t,r),this.deep,e);return this.children.store(e.lastName,n),n}createChild(e,t,r=null){return this.createChildWithNames(this.names.clone(e),t,r)}copy({deep:e,checker:t,children:r,data:n,names:s}){return this.checker===t?(this.deep=this.deep||e,this.children.copy(r),this.data=t.mergeConfigs(this.data,n,s)):console.error("TypeChecked objects can be merged only if using exactly same instance of type checker."),this}}var N=r(function(e,t){Object.defineProperty(t,"__esModule",{value:!0});const r=e=>"function"==typeof e;t.isFunction=r,t.default=r}),$=t(N),F=(N.isFunction,r(function(e,t){Object.defineProperty(t,"__esModule",{value:!0});const{isFunction:r}=N,n=e=>{const{apply:t,construct:n}=e;delete e.apply,delete e.construct;const s={...e,construct:n,apply:t};return t=>new Proxy(t,r(t)?s:e)};t.withProxy=n,t.default=n})),x=t(F);F.withProxy;const M=Symbol("type-checkers::target"),E=e=>Boolean(e&&e[M]),W=e=>(e=>{const t=typeof e;return Boolean(e)&&("function"===t||"object"===t)&&!f(e)})(e)&&!E(e),T=e=>(t,r)=>{const n=t[r];if(r===j)return n;if(r===M)return t;const a=V(t),{names:o,data:c,checker:i}=a,u=o.clone(r);return i.getProperty&&i.getProperty(t,u,n,c),!W(n)||((e,t,r,n)=>!(!$(n)||s(e,r)||!C("ignorePrototypeMethods",t)))(t,a,r,n)?n:((e,t,r,n)=>{const s=V(t),{deep:a}=s;if(a||$(n)){const{lastName:t}=r,a=s.getChild(t);return e(n,a||s.createChildWithNames(r,n))}return n})(e,t,u,n)},D=e=>(t,r,n)=>{if(r===M)throw new Error(`"${M}" is a virtual property and cannot be set`);if(r===j)return((e,t)=>{let r=V(e);return r&&t&&r!==t?r.copy(t):r=t,e[j]=r,!0})(t,n);const s=V(t);return W(n)&&C("wrapSetPropertyValues",s)?((e,t,r,n)=>{const s=V(t),{names:a,checker:o,data:c}=s,i=s.getChild(r),u=i?i.names:a.clone(r);return o.setProperty&&o.setProperty(t,u,n,c),n=e(n,i||s.createChild(u,n)),t[r]=n,!0})(e,t,r,n):((e,t,r)=>{const{names:n,data:s,checker:a}=V(e);return a.setProperty&&a.setProperty(e,n.clone(t),r,s),e[t]=r,!0})(t,r,n)},I=(e,t,r,n)=>{if(!W(n))return n;const s=t.getChild(r);return e(n,s||t.createChild(r,n))},A=(e,t,r)=>{if(C("wrapFunctionArguments",t)){const{length:n}=r;for(let s=0;s<n;s++)r[s]=I(e,t,String(s),r[s])}return r},B=(e,t=null)=>({get:(!t||t.get)&&T(e),set:(!t||t.set)&&D(e),apply:(!t||t.apply)&&(e=>(t,r,n)=>{const s=V(t),{names:a,data:o,checker:c}=s;c.arguments&&c.arguments(t,a,n,o,r),C("wrapFunctionArguments",s)&&(n=A(e,s,n));let i=t.apply(r,n);return c.returnValue&&c.returnValue(t,a,i,o,r),C("wrapFunctionReturnValues",s)&&(i=I(e,s,"returnValue",i)),i})(e),construct:(!t||t.construct)&&(e=>(t,r)=>{const n=V(t),{names:s,data:a,checker:o}=n;o.arguments&&o.arguments(t,s,r,a),C("wrapFunctionArguments",n)&&(r=A(e,n,r));let c=new t(...r);return o.returnValue&&o.returnValue(t,s,c,a),C("wrapFunctionReturnValues",n)&&(c=I(e,n,"returnValue",c)),c})(e),deleteProperty:(!t||t.deleteProperty)&&(()=>(e,t)=>{if(t===j)return delete e[t];if(t===M)return!1;const r=V(e),{names:n,data:s,checker:a}=r;return a.deleteProperty(e,n.clone(t),s),delete e[t]})()}),R=(e,{checker:t=o(),deep:r,names:n,data:s,children:a,info:c=null}={})=>c||((e,t,r,n,s)=>new S(e,t,r,n,s))(t,t.init(e,s),r,n,a),q=e=>{let t;const r=B((e,r)=>(_(e,r),t(e)),e);return t=x(r)},z=(e,t)=>{const{names:r,checker:n,data:s}=t;return Object.keys(e).forEach(a=>{const o=e[a],c=r.clone(a);if(n.getProperty&&n.getProperty(e,c,o,s),W(o)){let e=t.getChild(a);e||(e=t.createChildWithNames(c,o)),z(o,e)}}),_(e,t),t};e.getDefaultTypeChecker=o,e.setDefaultTypeChecker=c,e.isEnabled=i,e.setEnabled=u,e.addIgnoredClasses=d,e.isIgnoredClass=(e=>p.has(e)),e.isValueOfIgnoredClass=f,e.removeIgnoredClasses=((...e)=>{e.forEach(e=>p.delete(e))}),e.getWrapConfig=m,e.setWrapConfig=v,e.getWrapConfigValue=C,e.getTargetInfo=V,e.getTypeChecker=(e=>{if(e){const t=e[j];return t&&t.checker||void 0}}),e.getTypeCheckerData=(e=>{if(e){const t=e[j];return t&&t.data||void 0}}),e.removeTargetInfo=(e=>delete e[j]),e.wrap=((e,t,r=null)=>{if(!W(e)||!i())return e;return q(r)(e,R(e,t))}),e.wrapDeep=((e,t,r=null)=>{if(!W(e)||"object"!=typeof e||!i())return e;const n=q(r),s=R(e,t);return z(e,s),n(e,s)}),e.isWrappable=W,e.isWrapped=E,e.unwrap=(e=>e&&e[M]||e),Object.defineProperty(e,"__esModule",{value:!0})});
//# sourceMappingURL=type-checkers.min.js.map
