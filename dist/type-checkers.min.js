!function(e,t){"object"==typeof exports&&"undefined"!=typeof module?t(exports):"function"==typeof define&&define.amd?define(["exports"],t):t(e.TypeCheckers={})}(this,function(e){"use strict";let t=null;const r=()=>t;function n(e){return e&&e.__esModule&&Object.prototype.hasOwnProperty.call(e,"default")?e.default:e}function o(e,t){return e(t={exports:{}},t.exports),t.exports}var c=o(function(e,t){Object.defineProperty(t,"__esModule",{value:!0});const r=(e=>(t,r)=>Boolean(t&&e.call(t,r)))(Object.prototype.hasOwnProperty);t.hasOwn=r,t.default=r}),s=n(c);c.hasOwn;const i=()=>({wrapFunctionReturnValues:!0,wrapFunctionArguments:!1,wrapSetPropertyValues:!0,ignorePrototypeMethods:!1}),a={wrapFunctionReturnValues:!0,wrapFunctionArguments:!1,wrapSetPropertyValues:!0,ignorePrototypeMethods:!1},u=(e,t=null)=>s(t,e)?t[e]:a[e];var l=o(function(e,t){Object.defineProperty(t,"__esModule",{value:!0});const r=e=>"function"==typeof e;t.isFunction=r,t.default=r}),p=n(l),f=(l.isFunction,o(function(e,t){Object.defineProperty(t,"__esModule",{value:!0});const{isFunction:r}=l,n=e=>{const{apply:t,construct:n}=e;delete e.apply,delete e.construct;const o={...e,construct:n,apply:t};return t=>new Proxy(t,r(t)?o:e)};t.withProxy=n,t.default=n})),d=n(f);f.withProxy;const g=(e,t,r,n)=>`${e}Error on "${t}" instead of "${r}" received "${n}"`,y=(e,t,r,n)=>console.error(g(e,t,r,n));let h=y;const P=()=>h;let O=!0;const w=()=>O,b=Symbol("type-checkers::info"),m=(e={})=>Object.assign({},e),k=e=>e?e[b]:void 0,T=(e,t)=>{e&&t&&(e[b]=t)},_=e=>!!k(e),R=e=>`@${e}`,j=(e,t,r)=>{const n=R(t);delete e[n],r&&(e[n]=r)},E=(e,t,r)=>{j(e,t,k(r))},C=(e,t)=>e[R(t)],F=(e,t)=>{const{deep:r,checker:n,children:o,config:c,names:i}=e;return n===t.checker?(e.deep=r||t.deep,e.children=((e,t)=>{for(const r in t)s(e,r)?e[r]=F(e[r],t[r]):e[r]=t[r];return e})(o,t.children),e.config=n.mergeConfigs(c,t.config,i)):console.error("TypeChecked objects can be merged only if using exactly same instance of type checker."),e},V=Symbol("type-checkers::target"),x={object:!0,function:!0},S=e=>Boolean(e&&x[typeof e]),v=e=>Boolean(e&&e[V]),M=e=>(t,r)=>{const n=t[r];if(r===b)return n;if(r===V)return t;const o=k(t),{names:c,config:i,checker:a}=o;return a.getProperty&&a.getProperty(t,r,n,i,c),!S(n)||v(n)||((e,t,r,n)=>!(!p(n)||s(e,r)||!u("ignorePrototypeMethods",t)))(t,o,r,n)?n:((e,t,r,n)=>{const o=k(t),{deep:c,children:s,names:i,checker:a}=o;if(c||p(n)){const t=C(s,r);t?n=e(n,{info:t}):(n=e(n,{deep:c,names:[...i,r],checker:a}),E(s,r,n))}return n})(e,t,r,n)},A=e=>(t,r,n)=>{if(r===V)throw new Error(`"${V}" is a virtual property and cannot be set`);return((e,t,r)=>{if(t===b){let n=k(e);return n=n&&r&&n!==r?F(n,r):r,e[t]=n,!0}if(!S(r)){const{names:n,config:o,checker:c}=k(e);return c.setProperty&&c.setProperty(e,t,r,o,n),e[t]=r,!0}return!1})(t,r,n)||((e,t,r,n)=>{const o=k(t),{deep:c,names:s,checker:i,config:a,children:l}=o;if(i.setProperty&&i.setProperty(t,r,n,a,s),u("wrapSetPropertyValues",o)){if(!v(n)){const t=C(l,r);n=e(n,t?{info:t}:{deep:c,names:[...s,r],checker:i})}E(l,r,n)}return t[r]=n,!0})(e,t,r,n)},I=(e,t,r,n)=>{if(!S(n))return n;let o=n;if(!v(n)){const{children:c}=t,s=C(c,r);if(s)o=e(n,{info:s});else{const{deep:s,names:i,checker:a}=t;o=e(n,{deep:s,names:[...i,r],checker:a}),E(c,r,o)}}return o},N=e=>(t,r,n)=>{const o=k(t),{names:c,config:s,checker:i}=o;i.arguments&&i.arguments(t,r,n,s,c),n=((e,t,r)=>{const n=k(t);if(u("wrapFunctionArguments",n)){const{length:t}=r;for(let o=0;o<t;o++)r[o]=I(e,n,String(o),r[o])}return r})(e,t,n);let a=t.apply(r,n);return i.returnValue&&i.returnValue(t,r,a,s,c),u("wrapFunctionReturnValues",o)&&(a=I(e,o,"returnValue",a)),a};let D;const U=(e,{deep:t=!0,names:n=[],config:o=null,children:c=null,checker:s=r(),info:i=null}={})=>i||((e,t,r=!0,n=[],o=m())=>({checker:e,config:t,deep:r,names:n,children:o}))(s,s.init(e,P(),o),t,n,m(c)),Y=(e,t)=>S(e)&&w()&&!v(e)?(T(e,U(e,t)),D(e)):e;D=(()=>{const e=N(Y);return d({get:M(Y),set:A(Y),apply:e,construct:e})})();const $=(e,t)=>{const r=U(e,t),{deep:n,names:o,checker:c,config:s,children:i}=r;return Object.keys(e).forEach(t=>{const r=e[t];if(c.getProperty(e,t,r,s,o),S(r)){let e=C(i,t);e?$(r,{info:e}):(e=$(r,{deep:n,names:[...o,t],checker:c}),j(i,t,e))}}),T(e,r),r};e.getDefaultTypeChecker=r,e.setDefaultTypeChecker=(e=>{t=e}),e.PROXY_WRAP_FUNCTION_RETURN_VALUES="wrapFunctionReturnValues",e.PROXY_WRAP_FUNCTION_ARGUMENTS="wrapFunctionArguments",e.PROXY_WRAP_SET_PROPERTY_VALUES="wrapSetPropertyValues",e.PROXY_IGNORE_PROTOTYPE_METHODS="ignorePrototypeMethods",e.getDefaultProxyConfig=i,e.setProxyConfig=(e=>Object.assign(a,e)),e.getProxyConfig=(()=>Object.assign({},a)),e.create=Y,e.createDeep=((e,t)=>e&&"object"==typeof e&&w()&&!v(e)?($(e,t),D(e)):e),e.ConsoleErrorReporter=y,e.ConsoleWarnReporter=((e,t,r,n)=>console.warn(g(e,t,r,n))),e.ThrowErrorReporter=((e,t,r,n)=>{throw new Error(g(e,t,r,n))}),e.getErrorReporter=P,e.setErrorReporter=(e=>{h=e}),e.isEnabled=w,e.setEnabled=((e=!0)=>{O=!!e}),e.getTargetInfo=k,e.setTargetInfo=T,e.hasTargetInfo=_,e.getTargetTypeChecker=(e=>{if(e){const t=e[b];return t&&t.checker||void 0}}),e.getTargetTypeCheckerConfig=(e=>{if(e){const t=e[b];return t&&t.config||void 0}}),e.mergeTargetInfo=F,e.getOriginalTarget=(e=>e&&e[V]||e),e.merge=((e,...t)=>{let r={};return w()&&(e||(e={info:k(t.find(e=>_(e))),deep:!1}),r=Y(r,e)),Object.assign(r,...t)}),e.properties=((e,t,...r)=>{if(!w())return e;if(!S(e))throw new Error("Target must be a valid object.");if(Object.isFrozen(e)||Object.isSealed(e))throw new Error("Target object should not be sealed or frozen.");r.length||(r=Object.keys(e));const{length:n}=r;for(let o=0;o<n;o+=1){const n=r[o],{writable:c,get:s,set:i}=Object.getOwnPropertyDescriptor(e,n);if(s&&i||c){const r=e[n];S(r)&&!v(r)&&(e[n]=Y(r,t))}}return e}),e.isTypeChecked=v,e.isValidTarget=S,e.default=Y,Object.defineProperty(e,"__esModule",{value:!0})});
//# sourceMappingURL=type-checkers.min.js.map
