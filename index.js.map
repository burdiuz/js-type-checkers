{"version":3,"file":"index.js","sources":["source/config/default-checker.js","source/config/enabled.js","source/config/ignored-classes.js","source/config/wrap-config.js","source/info/children.js","source/info/target.js","source/info/utils.js","source/utils.js","source/proxy/handlers/get.js","source/proxy/handlers/set.js","source/proxy/handlers/apply.js","source/proxy/handlers/construct.js","source/proxy/handlers/deleteProperty.js","source/proxy/wrap.js","source/proxy/wrapDeep.js","source/object.js"],"sourcesContent":["import { singleValueFactory } from '@actualwave/closure-value';\n\nexport const {\n  get: getDefaultTypeChecker,\n  set: setDefaultTypeChecker,\n} = singleValueFactory();\n","import { singleValueFactory } from '@actualwave/closure-value';\n\nexport const {\n  get: isEnabled,\n  set: setEnabled,\n} = singleValueFactory(true, (value) => !!value);\n","import { getClass } from '@actualwave/get-class';\n\n/*\n When ignoring class, its instances will never be wrapped.\n*/\nconst constructors = new Set();\n\nexport const addIgnoredClasses = (...classes) => {\n  classes.forEach((constructor) => {\n    if (constructor && !constructors.has(constructor)) {\n      constructors.add(constructor);\n    }\n  });\n};\n\nexport const removeIgnoredClasses = (...classes) => {\n  classes.forEach((constructor) => constructors.delete(constructor));\n};\n\nexport const isIgnoredClass = (constructor) => constructors.has(constructor);\n\nexport const isValueOfIgnoredClass = (value) => constructors.has(getClass(value));\n\n/**\n * Number, String, Boolean and Symbol will not pass\n *\n *  typeof === 'object' || typeof === 'function'\n *\n * check, so not need to add them.\n */\naddIgnoredClasses(Map, Set, Date, Error);\n","import { valuesMapFactory } from '@actualwave/closure-value';\n\nexport const WRAP_FUNCTION_RETURN_VALUES = 'wrapFunctionReturnValues';\nexport const WRAP_FUNCTION_ARGUMENTS = 'wrapFunctionArguments';\nexport const WRAP_SET_PROPERTY_VALUES = 'wrapSetPropertyValues';\nexport const WRAP_IGNORE_PROTOTYPE_METHODS = 'ignorePrototypeMethods';\n\nconst { getDefault: getDefaultWrapConfig, set: setWrapConfigValue, get } = valuesMapFactory(\n  [\n    [WRAP_FUNCTION_RETURN_VALUES, true],\n    [WRAP_FUNCTION_ARGUMENTS, false],\n    [WRAP_SET_PROPERTY_VALUES, false],\n    [WRAP_IGNORE_PROTOTYPE_METHODS, false],\n  ],\n  (key, value) => !!value,\n);\n\nexport const getWrapConfigValue = (name, target) => {\n  let value;\n\n  if (target) {\n    value = target[name];\n  }\n\n  return value === undefined ? get(name) : value;\n};\n\nexport { getDefaultWrapConfig, setWrapConfigValue };\n","import hasOwn from '@actualwave/has-own';\n\n/*\n  I have had to apply custom key instead of name as is to\n  fix \"construtor\" issue. Since ordinary object has some\n  properties with values from start, these properties were\n  mustakenly returned as child info objects, for example, if\n  requesting hild info for \"constructor\" function of the target,\n  it returned class constructor which caused errors later,\n  when accesing info properties.\n\n  Converts Symbols and Numbers to String.\n\n  FIXME: Map might be fitting better.\n */\nconst getChildInfoKey = (name) => `@${String(name)}`;\n\nclass ChildrenCache {\n\n  constructor(children) {\n    if (children) {\n      this.cache = { ...children.cache };\n    } else {\n      this.cache = {};\n    }\n  }\n\n  store(name, childInfo) {\n    const key = getChildInfoKey(name);\n\n    if (childInfo) {\n      this.cache[key] = childInfo;\n    } else {\n      delete this.cache[key];\n    }\n  }\n\n  get(name) {\n    return this.cache[getChildInfoKey(name)];\n  }\n\n  has(name) {\n    return !!this.cache[getChildInfoKey(name)];\n  }\n\n  remove(cache, name) {\n    return delete this.cache[getChildInfoKey(name)];\n  }\n\n  copy({ cache: sourceCache }) {\n    Object.keys(sourceCache).forEach((key) => {\n      if (hasOwn(this.cache, key)) {\n        this.cache[key].copy(sourceCache[key]);\n      } else {\n        this.cache[key] = sourceCache[key];\n      }\n    });\n\n    return this;\n  }\n}\n\nexport const createChildrenCache = (children) => new ChildrenCache(children);\n\nexport default ChildrenCache;\n","import { createPathSequence } from '@actualwave/path-sequence-to-string';\n\nimport { createChildrenCache } from './children';\n\nexport const INFO_KEY = Symbol('type-checkers::info');\n\nexport const getTargetInfo = (target) => (target ? target[INFO_KEY] : undefined);\n\nexport const setTargetInfo = (target, info) => {\n  if (target && info) {\n    target[INFO_KEY] = info;\n  }\n};\n\nexport const removeTargetInfo = (target) => delete target[INFO_KEY];\n\nexport const hasTargetInfo = (target) => !!getTargetInfo(target);\n\nclass TargetInfo {\n  constructor(\n    checker,\n    data = null,\n    deep = true,\n    names = createPathSequence(),\n    children = createChildrenCache(),\n  ) {\n    this.checker = checker;\n    this.data = data;\n    this.deep = deep;\n    this.names = names;\n    this.children = children;\n  }\n\n  getChild(name) {\n    return this.children.get(name);\n  }\n\n  storeChildFrom(name, child) {\n    const info = getTargetInfo(child);\n\n    if (info) {\n      this.children.store(name, info);\n    }\n  }\n\n  createChildWithNames(names, value, data = null) {\n    const childInfo = new TargetInfo(\n      this.checker,\n      this.checker.init(value, data),\n      this.deep,\n      names,\n    );\n\n    this.children.store(names.lastName, childInfo);\n\n    return childInfo;\n  }\n\n  createChild(name, value, data = null) {\n    return this.createChildWithNames(this.names.clone(name), value, data);\n  }\n\n  copy({ deep, checker, children, data, names }) {\n    if (this.checker === checker) {\n      this.deep = this.deep || deep;\n      this.children.copy(children);\n      this.data = checker.mergeConfigs(this.data, data, names);\n    } else {\n      console.error(\n        'TypeChecked objects can be merged only if using exactly same instance of type checker.',\n      );\n    }\n\n    return this;\n  }\n}\n\nexport const createTargetInfo = (checker, data, deep, names, children) =>\n  new TargetInfo(checker, data, deep, names, children);\n","import { INFO_KEY } from './target';\n\nexport const getTypeChecker = (target) => {\n  if (target) {\n    const info = target[INFO_KEY];\n\n    return (info && info.checker) || undefined;\n  }\n\n  return undefined;\n};\n\nexport const getTypeCheckerData = (target) => {\n  if (target) {\n    const info = target[INFO_KEY];\n\n    return (info && info.data) || undefined;\n  }\n\n  return undefined;\n};\n","import { isValueOfIgnoredClass } from './config/ignored-classes';\nimport { getTargetInfo } from './info';\nimport {\n  WRAP_FUNCTION_ARGUMENTS,\n  WRAP_FUNCTION_RETURN_VALUES,\n  WRAP_IGNORE_PROTOTYPE_METHODS,\n  WRAP_SET_PROPERTY_VALUES,\n} from './config/wrap-config';\n\nexport const TARGET_KEY = Symbol('type-checkers::target');\n\nexport const isSymbol = (value) => typeof value === 'symbol';\n\nexport const isOfWrappableType = (target) => {\n  const type = typeof target;\n\n  return (\n    Boolean(target) && (type === 'function' || type === 'object') && !isValueOfIgnoredClass(target)\n  );\n};\n\nexport const isWrapped = (target) => Boolean(target && target[TARGET_KEY]);\n\nexport const isWrappable = (target) => isOfWrappableType(target) && !isWrapped(target);\n\nexport const unwrap = (target) => (target && target[TARGET_KEY]) || target;\n\nexport const setWrapConfigTo = (target, key, value) => {\n  if (!isWrapped(target)) {\n    return false;\n  }\n\n  const info = getTargetInfo(target);\n\n  switch (key) {\n    case WRAP_FUNCTION_RETURN_VALUES:\n    case WRAP_FUNCTION_ARGUMENTS:\n    case WRAP_SET_PROPERTY_VALUES:\n    case WRAP_IGNORE_PROTOTYPE_METHODS:\n      info[key] = !!value;\n      return true;\n    default:\n      return false;\n  }\n};\n","import hasOwn from '@actualwave/has-own';\nimport isFunction from '@actualwave/is-function';\n\nimport { isWrappable, isSymbol, TARGET_KEY } from '../../utils';\nimport { INFO_KEY, getTargetInfo } from '../../info';\nimport { getWrapConfigValue, WRAP_IGNORE_PROTOTYPE_METHODS } from '../../config/wrap-config';\n\nconst getTargetProperty = (wrapFn, target, names, value) => {\n  const info = getTargetInfo(target);\n  const { deep } = info;\n\n  if (deep || isFunction(value)) {\n    const { lastName: property } = names;\n\n    const childInfo = info.getChild(property);\n\n    if (childInfo) {\n      return wrapFn(value, childInfo);\n    }\n\n    return wrapFn(value, info.createChildWithNames(names, value));\n  }\n\n  return value;\n};\n\n/**\n * Skips prototype methods if they are ignored by config\n */\nconst isIgnoredProperty = (target, info, property, value) => {\n  if (\n    isFunction(value) &&\n    !hasOwn(target, property) &&\n    getWrapConfigValue(WRAP_IGNORE_PROTOTYPE_METHODS, info)\n  ) {\n    return true;\n  }\n\n  return false;\n};\n\nconst getPropertyFactory = (wrapFn) => (target, property) => {\n  const value = target[property];\n\n  if (property === INFO_KEY) {\n    return value;\n    /*\n    target[TARGET_KEY] is a virtual property accessing which indicates\n    if object is wrapped with type checked proxy or not.\n    Also it allows \"unwrapping\" target.\n    */\n  }\n\n  if (property === TARGET_KEY) {\n    return target;\n  }\n\n  if (isSymbol(property)) {\n    return target[property];\n  }\n\n  const info = getTargetInfo(target);\n  const { names, data, checker } = info;\n\n  const nextNames = names.clone(property);\n\n  if (checker.getProperty) {\n    checker.getProperty(target, nextNames, value, data);\n  }\n\n  if (!isWrappable(value) || isIgnoredProperty(target, info, property, value)) {\n    return value;\n  }\n\n  return getTargetProperty(wrapFn, target, nextNames, value);\n};\n\nexport default getPropertyFactory;\n","import { INFO_KEY, getTargetInfo } from '../../info';\nimport { TARGET_KEY, isSymbol, isWrappable } from '../../utils';\nimport { getWrapConfigValue, WRAP_SET_PROPERTY_VALUES } from '../../config/wrap-config';\n\nconst setNonTargetProperty = (target, property, value) => {\n  const { names, data, checker } = getTargetInfo(target);\n\n  if (checker.setProperty) {\n    checker.setProperty(target, names.clone(property), value, data);\n  }\n\n  target[property] = value;\n\n  return true;\n};\n\nconst setTargetProperty = (wrapFn, target, property, value) => {\n  const info = getTargetInfo(target);\n  const { names, checker, data } = info;\n  const childInfo = info.getChild(property);\n  const nextNames = childInfo ? childInfo.names : names.clone(property);\n\n  if (checker.setProperty) {\n    checker.setProperty(target, nextNames, value, data);\n  }\n\n  if (childInfo) {\n    value = wrapFn(value, childInfo);\n  } else {\n    value = wrapFn(value, info.createChildWithNames(nextNames, value));\n  }\n\n  target[property] = value;\n  return true;\n};\n\nconst updateTargetInfo = (target, value) => {\n  let info = getTargetInfo(target);\n  if (info && value && info !== value) {\n    info.copy(value);\n  } else {\n    info = value;\n  }\n\n  target[INFO_KEY] = info;\n  return true;\n};\n\nconst setPropertyFactory = (wrapFn) => (target, property, value) => {\n  if (property === TARGET_KEY) {\n    throw new Error(`\"${TARGET_KEY}\" is a virtual property and cannot be set`);\n  }\n\n  if (property === INFO_KEY) {\n    return updateTargetInfo(target, value);\n  }\n\n  if (isSymbol(property)) {\n    return updateTargetInfo(target, value);\n  }\n\n  const info = getTargetInfo(target);\n\n  if (isWrappable(value) && getWrapConfigValue(WRAP_SET_PROPERTY_VALUES, info)) {\n    return setTargetProperty(wrapFn, target, property, value);\n  }\n\n  return setNonTargetProperty(target, property, value);\n};\n\nexport default setPropertyFactory;\n","import { getTargetInfo } from '../../info';\nimport { isWrappable } from '../../utils';\n\nimport {\n  getWrapConfigValue,\n  WRAP_FUNCTION_ARGUMENTS,\n  WRAP_FUNCTION_RETURN_VALUES,\n} from '../../config/wrap-config';\n\nexport const getTypeCheckedChild = (wrapFn, info, name, value) => {\n  if (!isWrappable(value)) {\n    return value;\n  }\n\n  const childInfo = info.getChild(name);\n\n  if (childInfo) {\n    return wrapFn(value, childInfo);\n  }\n\n  return wrapFn(value, info.createChild(name, value));\n};\n\nexport const getTargetArguments = (wrapFn, info, argumentsList) => {\n  if (getWrapConfigValue(WRAP_FUNCTION_ARGUMENTS, info)) {\n    const { length } = argumentsList;\n    for (let index = 0; index < length; index++) {\n      argumentsList[index] = getTypeCheckedChild(wrapFn, info, String(index), argumentsList[index]);\n    }\n  }\n\n  return argumentsList;\n};\n\nconst applyFunctionFactory = (wrapFn) => (target, thisArg, argumentsList) => {\n  const info = getTargetInfo(target);\n  const { names, data, checker } = info;\n\n  if (checker.arguments) {\n    checker.arguments(target, names, argumentsList, data, thisArg);\n  }\n\n  if (getWrapConfigValue(WRAP_FUNCTION_ARGUMENTS, info)) {\n    argumentsList = getTargetArguments(wrapFn, info, argumentsList);\n  }\n\n  let result = target.apply(thisArg, argumentsList);\n\n  if (checker.returnValue) {\n    checker.returnValue(target, names, result, data, thisArg);\n  }\n\n  if (getWrapConfigValue(WRAP_FUNCTION_RETURN_VALUES, info)) {\n    result = getTypeCheckedChild(wrapFn, info, 'returnValue', result);\n  }\n\n  return result;\n};\n\nexport default applyFunctionFactory;\n","import { getTargetInfo } from '../../info';\nimport {\n  getWrapConfigValue,\n  WRAP_FUNCTION_ARGUMENTS,\n  WRAP_FUNCTION_RETURN_VALUES,\n} from '../../config/wrap-config';\nimport { getTargetArguments, getTypeCheckedChild } from './apply';\n\nconst constructFactory = (wrapFn) => (Target, argumentsList) => {\n  const info = getTargetInfo(Target);\n  const { names, data, checker } = info;\n\n  if (checker.arguments) {\n    checker.arguments(Target, names, argumentsList, data);\n  }\n\n  if (getWrapConfigValue(WRAP_FUNCTION_ARGUMENTS, info)) {\n    argumentsList = getTargetArguments(wrapFn, info, argumentsList);\n  }\n\n  let result = new Target(...argumentsList);\n\n  if (checker.returnValue) {\n    checker.returnValue(Target, names, result, data);\n  }\n\n  if (getWrapConfigValue(WRAP_FUNCTION_RETURN_VALUES, info)) {\n    result = getTypeCheckedChild(wrapFn, info, 'returnValue', result);\n  }\n\n  return result;\n};\n\nexport default constructFactory;\n","import { INFO_KEY, getTargetInfo } from '../../info';\nimport { TARGET_KEY, isSymbol } from '../../utils';\n\nconst deletePropertyFactory = () => (target, property) => {\n  if (property === INFO_KEY) {\n    return delete target[property];\n  }\n\n  if (property === TARGET_KEY) {\n    return false;\n  }\n\n  if (isSymbol(property)) {\n    return delete target[property];\n  }\n\n  const info = getTargetInfo(target);\n  const { names, data, checker } = info;\n\n  checker.deleteProperty(target, names.clone(property), data);\n\n  return delete target[property];\n};\n\nexport default deletePropertyFactory;\n","/* eslint-disable import/prefer-default-export */\nimport withProxy from '@actualwave/with-proxy';\nimport { createPathSequence } from '@actualwave/path-sequence-to-string';\n\nimport { isWrappable } from '../utils';\nimport { setTargetInfo, createTargetInfo } from '../info';\nimport { isEnabled } from '../config/enabled';\nimport { getDefaultTypeChecker } from '../config/default-checker';\n\nimport getPropertyFactory from './handlers/get';\nimport setPropertyFactory from './handlers/set';\nimport applyFunctionFactory from './handlers/apply';\nimport constructFactory from './handlers/construct';\nimport deletePropertyFactory from './handlers/deleteProperty';\n\nexport const createInfoFromOptions = (\n  target,\n  {\n    checker = getDefaultTypeChecker(),\n    deep,\n    name,\n    data,\n    children,\n    info = null, // exclusive option, if set other options being ignored\n  } = {},\n) =>\n  info ||\n  createTargetInfo(checker, checker.init(target, data), deep, createPathSequence(name), children);\n\nconst generateHandlers = (create, config = null) => ({\n  get: (!config || config.get) && getPropertyFactory(create),\n  set: (!config || config.set) && setPropertyFactory(create),\n  apply: (!config || config.apply) && applyFunctionFactory(create),\n  construct: (!config || config.construct) && constructFactory(create),\n  deleteProperty: (!config || config.deleteProperty) && deletePropertyFactory(create),\n});\n\nexport const createWrapFactory = (proxyConfig) => {\n  let wrapInternal;\n  const assignInfoAndWrap = (target, info) => {\n    setTargetInfo(target, info);\n    return wrapInternal(target);\n  };\n\n  const handlers = generateHandlers(assignInfoAndWrap, proxyConfig);\n  wrapInternal = withProxy(handlers);\n\n  return assignInfoAndWrap;\n};\n\nexport const wrap = (target, options = null, proxyConfig = null) => {\n  if (!isWrappable(target) || !isEnabled()) {\n    return target;\n  }\n\n  const wrapInternal = createWrapFactory(proxyConfig);\n  const info = createInfoFromOptions(target, options || undefined);\n\n  return wrapInternal(target, info);\n};\n","/* eslint-disable import/prefer-default-export */\nimport { isEnabled } from '../config/enabled';\nimport { setTargetInfo } from '../info';\nimport { isWrappable } from '../utils';\nimport { createInfoFromOptions, createWrapFactory } from './wrap';\n\nconst deepInitializer = (target, info) => {\n  const { names, checker, data } = info;\n\n  Object.keys(target).forEach((name) => {\n    const value = target[name];\n    const nextNames = names.clone(name);\n\n    if (checker.getProperty) {\n      checker.getProperty(target, nextNames, value, data);\n    }\n\n    if (isWrappable(value)) {\n      let childInfo = info.getChild(name);\n\n      if (!childInfo) {\n        childInfo = info.createChildWithNames(nextNames, value);\n      }\n\n      deepInitializer(value, childInfo);\n    }\n  });\n\n  setTargetInfo(target, info);\n\n  return info;\n};\n\nexport const wrapDeep = (target, options, proxyConfig = null) => {\n  if (!isWrappable(target) || typeof target !== 'object' || !isEnabled()) {\n    return target;\n  }\n\n  const wrapInternal = createWrapFactory(proxyConfig);\n  const info = createInfoFromOptions(target, options);\n\n  deepInitializer(target, info);\n\n  return wrapInternal(target, info);\n};\n","import { wrap } from './proxy/wrap';\nimport { isWrapped } from './utils';\nimport { getTargetInfo } from './info';\n\nconst findWrapped = (list) => list.find(isWrapped);\n\n/**\n * Merge all objects and return new. If any of source objects were wrapped,\n * resulting object will be wrapped.\n * @param  {...any} sources\n */\nexport const merge = (...sources) => {\n  const wrapped = findWrapped(sources);\n\n  if (!wrapped) {\n    return Object.assign({}, ...sources);\n  }\n\n  const info = getTargetInfo(wrapped);\n\n  return Object.assign(wrap({}, { info }), ...sources);\n};\n\n/**\n * Calls merge() and forces wrapped result.\n * @param {*} options\n * @param  {...Object} sources\n */\nmerge.options = (options, ...sources) => merge(wrap({}, options), ...sources);\n\n/**\n * Assign properties from source objects to target. If target or any of sources\n * were wrapped, resulting object will be wrapped.\n * @param {*} target\n * @param  {...any} sources\n */\nexport const assign = (target, ...sources) => {\n  if (isWrapped(target)) {\n    return Object.assign(target, ...sources);\n  }\n\n  const wrapped = findWrapped(sources);\n\n  if (!wrapped) {\n    return Object.assign(target, ...sources);\n  }\n\n  const info = getTargetInfo(wrapped);\n\n  return Object.assign(wrap(target, { info }), ...sources);\n};\n\n/**\n * calls assign() and forces wrapped result.\n * @param {*} options\n * @param {Object} target\n * @param  {...Object} sources\n */\nassign.options = (options, target, ...sources) => assign(wrap(target, options), ...sources);\n"],"names":["get","getDefaultTypeChecker","set","setDefaultTypeChecker","singleValueFactory","isEnabled","setEnabled","value","constructors","Set","addIgnoredClasses","classes","forEach","constructor","has","add","removeIgnoredClasses","delete","isIgnoredClass","isValueOfIgnoredClass","getClass","Map","Date","Error","WRAP_FUNCTION_RETURN_VALUES","WRAP_FUNCTION_ARGUMENTS","WRAP_SET_PROPERTY_VALUES","WRAP_IGNORE_PROTOTYPE_METHODS","getDefault","getDefaultWrapConfig","setWrapConfigValue","valuesMapFactory","key","getWrapConfigValue","name","target","undefined","getChildInfoKey","String","ChildrenCache","children","cache","store","childInfo","remove","copy","sourceCache","Object","keys","hasOwn","createChildrenCache","INFO_KEY","Symbol","getTargetInfo","setTargetInfo","info","removeTargetInfo","TargetInfo","checker","data","deep","names","createPathSequence","getChild","storeChildFrom","child","createChildWithNames","init","lastName","createChild","clone","mergeConfigs","console","error","createTargetInfo","getTypeChecker","getTypeCheckerData","TARGET_KEY","isSymbol","isOfWrappableType","type","Boolean","isWrapped","isWrappable","unwrap","setWrapConfigTo","getTargetProperty","wrapFn","isFunction","property","isIgnoredProperty","getPropertyFactory","nextNames","getProperty","setNonTargetProperty","setProperty","setTargetProperty","updateTargetInfo","setPropertyFactory","getTypeCheckedChild","getTargetArguments","argumentsList","length","index","applyFunctionFactory","thisArg","arguments","result","apply","returnValue","constructFactory","Target","deletePropertyFactory","deleteProperty","createInfoFromOptions","generateHandlers","create","config","construct","createWrapFactory","proxyConfig","wrapInternal","assignInfoAndWrap","handlers","withProxy","wrap","options","deepInitializer","wrapDeep","findWrapped","list","find","merge","sources","wrapped","assign"],"mappings":"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"}